#!/usr/bin/env python2

import string

print """; NOTE: Tests autogenerated by utils/EPI/generate-intrinsics-tests.py
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+a,+c,+epi -verify-machineinstrs < %s \\
; RUN:    | FileCheck %s

@scratch = global i8 0, align 16
"""

MAX_VLMUL = 8
MAX_SEW = 64

class SingleType(object):
    def __init__(self, value_type, llvm_type, sew, is_mask_type, corr_integer_type = None):
        self.value_type = value_type
        self.llvm_type = llvm_type
        self.sew = sew
        self.is_mask_type = is_mask_type
        # Corresponding integer type (ie. integer type with same SEW)
        self.corr_integer_type = corr_integer_type

        if self.corr_integer_type is None:
            self.corr_integer_type = self

    def get_base_scale(self):
        return (MAX_SEW/self.sew)

class IntrinsicType(object):
    def __init__(self, result, operands):
        self.result = result
        self.operands = operands

mask_types = [
    # Mask types do not scale according to a SEW, and thus it is set to 0
    SingleType("i1", "i1", -1, True),
]

def generate_unary_mask_types():
    assert(len(mask_types) == 1)
    yield IntrinsicType(mask_types[0], [mask_types[0]])

def generate_binary_mask_types():
    assert(len(mask_types) == 1)
    yield IntrinsicType(mask_types[0], [mask_types[0]] * 2)

integer_type_i8 = SingleType("i8", "i8", 8, False)
integer_type_i16 = SingleType("i16", "i16", 16, False)
integer_type_i32 = SingleType("i32", "i32", 32, False)
integer_type_i64 = SingleType("i64", "i64", 64, False)

integer_types = [
        integer_type_i8,
        integer_type_i16,
        integer_type_i32,
        integer_type_i64,
]

def generate_unary_mask_to_integer_types():
    for x in integer_types:
        assert(len(mask_types) == 1)
        yield IntrinsicType(x, [mask_types[0]])

def generate_binary_integer_types():
    for x in integer_types:
        yield IntrinsicType(x, [x] * 2)

def generate_binary_integer_types_relational():
    for x in integer_types:
        assert(len(mask_types) == 1)
        yield IntrinsicType(mask_types[0], [x] * 2)

def generate_binary_integer_types_widened():
    for i in range(0, len(integer_types) - 1):
        yield IntrinsicType(integer_types[i + 1], \
                [integer_types[i]]*2)

def generate_binary_integer_types_widened_lhs():
    for i in range(0, len(integer_types) - 1):
        yield IntrinsicType(integer_types[i + 1], \
                [integer_types[i + 1], integer_types[i]])

def generate_binary_integer_types_narrowed():
    for i in range(0, len(integer_types) - 1):
        yield IntrinsicType(integer_types[i], \
                [integer_types[i + 1], integer_types[i]])

def generate_ternary_integer_types():
    for x in integer_types:
        yield IntrinsicType(x, [x] * 3)

def generate_ternary_integer_types_widened():
    for i in range(0, len(integer_types) - 1):
        yield IntrinsicType(integer_types[i + 1], \
                [integer_types[i]] * 3)

float_type_f32 = SingleType("f32", "float", 32, False, integer_type_i32)
float_type_f64 = SingleType("f64", "double", 64, False, integer_type_i64)

float_types = [
        float_type_f32,
        float_type_f64,
]

def generate_unary_integer_types():
    for x in integer_types:
        yield IntrinsicType(x, [x])

def generate_unary_float_types():
    for x in float_types:
        yield IntrinsicType(x, [x])

def generate_unary_vfclass_types():
    for i in [integer_type_i32, integer_type_i64]:
        for x in float_types:
            yield IntrinsicType(i, [x])

def generate_binary_float_types():
    for x in float_types:
        yield IntrinsicType(x, [x, x])

def generate_binary_float_types_relational():
    for x in float_types:
        assert(len(mask_types) == 1)
        yield IntrinsicType(mask_types[0], [x, x])

def generate_binary_float_types_widened():
    for i in range(0, len(float_types) - 1):
        yield IntrinsicType(float_types[i + 1], \
                [float_types[i]]*2)

def generate_binary_float_types_widened_lhs():
    for i in range(0, len(float_types) - 1):
        yield IntrinsicType(float_types[i + 1], \
                [float_types[i + 1], float_types[i]])

def generate_binary_float_types_widened():
    for i in range(0, len(float_types) - 1):
        yield IntrinsicType(float_types[i + 1], \
                [float_types[i]]*2)

def generate_ternary_float_types():
    for x in float_types:
        yield IntrinsicType(x, [x]*3)

def generate_ternary_float_types_widened():
    for i in range(0, len(float_types) - 1):
        yield IntrinsicType(float_types[i + 1], \
                [float_types[i]]*3)

# Any
def generate_binary_any_types():
    for x in integer_types + float_types + mask_types:
        yield IntrinsicType(x, [x] * 2)

def generate_binary_any_and_mask_types():
    for x in integer_types + float_types:
        assert(len(mask_types) == 1)
        yield IntrinsicType(x, [x, mask_types[0]])

def generate_binary_any_and_integer_types():
    for x in integer_types + float_types:
        assert(len(mask_types) == 1)
        yield IntrinsicType(x, [x, x.corr_integer_type])

def generate_same_size_float_to_integer_types():
    yield IntrinsicType(integer_type_i32, [float_type_f32])
    yield IntrinsicType(integer_type_i64, [float_type_f64])

def generate_same_size_integer_to_float_types():
    yield IntrinsicType(float_type_f32, [integer_type_i32])
    yield IntrinsicType(float_type_f64, [integer_type_i64])

def generate_widened_float_to_float_types():
    yield IntrinsicType(float_type_f64, [float_type_f32])

def generate_narrow_float_to_float_types():
    yield IntrinsicType(float_type_f32, [float_type_f64])

def generate_nullary_integer_types():
    for x in integer_types:
        yield IntrinsicType(x, [])

def generate_mask_to_int_types():
    yield IntrinsicType(integer_type_i64, [mask_types[0]])

################################################################################
################################################################################
################################################################################

class Intrinsic(object):
    def __init__(self, intr_name, type_generator, **extra_info):
        self.intr_name = intr_name
        self.type_generator = type_generator
        self.instruction = extra_info.get("instruction", self.intr_name)
        self.variants = extra_info["variants"]
        self.mask = extra_info.get("mask", True)
        self.vlmul_values = extra_info.get("vlmul_values", [1, 2, 4, 8])

    def render(self):
        raise Exception("abstract method")

class NullaryIntrinsic(Intrinsic):
    pattern_v = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}();
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}
; CHECK:       ${instruction}.${suffix} v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}()
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_v_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}(<vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}
; CHECK:       ${instruction}.${suffix} v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}(<vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(NullaryIntrinsic, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["v"]:
            result = NullaryIntrinsic.pattern_v
            if self.mask:
                result += NullaryIntrinsic.pattern_v_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                print template.substitute(subs)

class UnaryIntrinsicMask(Intrinsic):
    pattern_m = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}(<vscale x 1 x ${llvm_lhs_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}(<vscale x 1 x ${llvm_lhs_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_m_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.mask(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""

    def __init__(self, intr_name, type_generator, **extra_info):
        super(UnaryIntrinsicMask, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["m"]:
            result = UnaryIntrinsicMask.pattern_m
            if self.mask:
                result += UnaryIntrinsicMask.pattern_m_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                print template.substitute(subs)

class UnaryIntrinsic(Intrinsic):
    pattern_v = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}(<vscale x 1 x ${llvm_lhs_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}(<vscale x 1 x ${llvm_lhs_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_v_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(UnaryIntrinsic, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["v", "m"]:
            result = UnaryIntrinsic.pattern_v
            if self.mask:
                result += UnaryIntrinsic.pattern_v_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                print template.substitute(subs)

class UnaryIntrinsicScalarResult(Intrinsic):
    pattern_v = """
declare ${llvm_result_type} @llvm.epi.${intrinsic}(<vscale x 1 x ${llvm_lhs_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} a0, v0
  %a = call ${llvm_result_type} @llvm.epi.${intrinsic}(<vscale x 1 x ${llvm_lhs_type}> undef)
  %p = bitcast i8* @scratch to ${llvm_result_type}*
  store ${llvm_result_type} %a, ${llvm_result_type}* %p
  ret void
}
"""
    pattern_v_mask = """
declare ${llvm_result_type} @llvm.epi.${intrinsic}.mask(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} a0, v0, v0.t
  %a = call ${llvm_result_type} @llvm.epi.${intrinsic}.mask(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to ${llvm_result_type}*
  store ${llvm_result_type} %a, ${llvm_result_type}* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(UnaryIntrinsicScalarResult, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["m"]:
            result = UnaryIntrinsicScalarResult.pattern_v
            if self.mask:
                result += UnaryIntrinsicScalarResult.pattern_v_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                print template.substitute(subs)

class UnaryIntrinsicScalarInput(Intrinsic):
    pattern_v = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_lhs_type}(${llvm_lhs_type});
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, ${scalar_register}
  %a = call <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_lhs_type}(${llvm_lhs_type} undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_v_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.${value_lhs_type}(${llvm_lhs_type}, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, ${scalar_register}, v0.t
  %a = call <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.${value_lhs_type}(${llvm_lhs_type} undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        self.scalar_register = extra_info["scalar_register"]
        del extra_info["scalar_register"]
        super(UnaryIntrinsicScalarInput, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["vx", "vf"]:
            result = UnaryIntrinsicScalarInput.pattern_v
            if self.mask:
                result += UnaryIntrinsicScalarInput.pattern_v_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            op_subs["scalar_register"] = self.scalar_register
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                print template.substitute(subs)

class Conversion(Intrinsic):
    pattern_v = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.${suffix}.nxv1${value_result_type}.nxv1${value_lhs_type}(<vscale x 1 x ${llvm_lhs_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix}.v v0, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.${suffix}.nxv1${value_result_type}.nxv1${value_lhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_v_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.${suffix}.mask.nxv1${value_result_type}.nxv1${value_lhs_type}(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}
; CHECK:       ${instruction}.${suffix}.v v0, v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.${suffix}.mask.nxv1${value_result_type}.nxv1${value_lhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(Conversion, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        result += Conversion.pattern_v
        if self.mask:
            result += Conversion.pattern_v_mask
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                print template.substitute(subs)

class BinaryIntrinsic(Intrinsic):
    pattern_vv = """
declare <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv${result_type_scale}${value_result_type}.nxv${rhs_type_scale}${value_rhs_type}(
  <vscale x ${lhs_type_scale} x ${llvm_lhs_type}>,
  <vscale x ${rhs_type_scale} x ${llvm_rhs_type}>,
  i64);

define void @intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_nxv${rhs_type_scale}${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_nxv${rhs_type_scale}${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, v0
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv${result_type_scale}${value_result_type}.nxv${rhs_type_scale}${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    <vscale x ${rhs_type_scale} x ${llvm_rhs_type}> undef,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""
    pattern_vv_mask = """
declare <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv${result_type_scale}${value_result_type}.nxv${rhs_type_scale}${value_rhs_type}(
  <vscale x ${lhs_type_scale} x ${llvm_lhs_type}>,
  <vscale x ${rhs_type_scale} x ${llvm_rhs_type}>,
  <vscale x ${lhs_type_scale} x i1>,
  i64);

define void @intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_nxv${rhs_type_scale}${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_nxv${rhs_type_scale}${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, v0, v0.t
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv${result_type_scale}${value_result_type}.nxv${rhs_type_scale}${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    <vscale x ${rhs_type_scale} x ${llvm_rhs_type}> undef,
    <vscale x ${lhs_type_scale} x i1> undef,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""
    pattern_vx = """
declare <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
  <vscale x ${lhs_type_scale} x ${llvm_lhs_type}>,
  ${llvm_rhs_type},
  i64);

define void @intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, ${scalar_register}
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    ${llvm_rhs_type} undef,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""
    pattern_vx_mask = """
declare <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
  <vscale x ${lhs_type_scale} x ${llvm_lhs_type}>,
  ${llvm_rhs_type},
  <vscale x ${lhs_type_scale} x i1>,
  i64);

define void @intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, ${scalar_register}, v0.t
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    ${llvm_rhs_type} undef,
    <vscale x ${lhs_type_scale} x i1> undef,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""
    pattern_vi = """
define void @intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, 9
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    ${llvm_rhs_type} 9,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""
    pattern_vi_mask = """
define void @intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_nxv${result_type_scale}${value_result_type}_nxv${lhs_type_scale}${value_lhs_type}_${value_rhs_type}
; CHECK:       vsetvli {{.*}}, a0, ${sew}, ${vlmul}
; CHECK:       ${instruction}.${suffix} v0, v0, 9, v0.t
  %a = call <vscale x ${result_type_scale} x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv${result_type_scale}${value_result_type}.${value_rhs_type}(
    <vscale x ${lhs_type_scale} x ${llvm_lhs_type}> undef,
    ${llvm_rhs_type} 9,
    <vscale x ${lhs_type_scale} x i1> undef,
    i64 undef)

  %p = bitcast i8* @scratch to <vscale x ${result_type_scale} x ${llvm_result_type}>*
  store <vscale x ${result_type_scale} x ${llvm_result_type}> %a, <vscale x ${result_type_scale} x ${llvm_result_type}>* %p

  ret void
}
"""

    def __init__(self, intr_name, type_generator, **extra_info):
        super(BinaryIntrinsic, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["vv", "wv", "vm", "mm", "vs"]:
            result += BinaryIntrinsic.pattern_vv
            if self.mask:
                result += BinaryIntrinsic.pattern_vv_mask
        elif variant in ["vx", "vf", "wx", "wf"]:
            result += BinaryIntrinsic.pattern_vx
            if self.mask:
                result += BinaryIntrinsic.pattern_vx_mask
        elif variant == "vi":
            result += BinaryIntrinsic.pattern_vi
            if self.mask:
                result += BinaryIntrinsic.pattern_vi_mask
        else:
            raise Exception("Unhandled variant '{}'".format(variant))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]
                rhs = intrinsic_type.operands[1]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["llvm_rhs_type"] = rhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                subs["value_rhs_type"] = rhs.value_type

                subs["sew"] = "e" + str(min(lhs.sew, rhs.sew))

                for vlmul in self.vlmul_values:
                    # vlmul here is 'base' vlmul, vlmul for SEW operand
                    # (as opposed to 2*SEW operand)
                    subs["vlmul"] = "m" + str(vlmul)

                    # Ensure all operands have the same scale (ie. number of elements)
                    result_scale = result.get_base_scale()
                    lhs_scale = lhs.get_base_scale()
                    rhs_scale = rhs.get_base_scale()
                    max_scale = max(result_scale, lhs_scale, rhs_scale)

                    # Check legal VLMUL for non-mask types
                    if (not result.is_mask_type) and (result_scale != max_scale):
                        result_vlmul = vlmul*(max_scale/result_scale)
                        assert(result_vlmul <= MAX_VLMUL)

                    if (not lhs.is_mask_type) and (lhs_scale != max_scale):
                        lhs_vlmul = vlmul*(max_scale/lhs_scale)
                        assert(lhs_vlmul <= MAX_VLMUL)

                    if (not rhs.is_mask_type) and (rhs_scale != max_scale):
                        rhs_vlmul = vlmul*(max_scale/rhs_scale)
                        assert(rhs_vlmul <= MAX_VLMUL)

                    # FIXME: nxv64T types not defined (ie. nxv64i8)
                    if max_scale*vlmul >= 64:
                        continue

                    subs["result_type_scale"] = max_scale*vlmul
                    subs["lhs_type_scale"] = max_scale*vlmul
                    subs["rhs_type_scale"] = max_scale*vlmul

                    if v in ["vf", "wf"]:
                        subs["scalar_register"] = "ft0"
                    elif v in ["vx", "wx", "vm", "mm"]:
                        subs["scalar_register"] = "a0"

                    print template.substitute(subs)


class TernaryIntrinsic(Intrinsic):
    pattern_vv = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x ${llvm_rhs_type}>, <vscale x 1 x ${llvm_result_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x ${llvm_rhs_type}> undef, <vscale x 1 x ${llvm_result_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_vv_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x ${llvm_rhs_type}>, <vscale x 1 x ${llvm_result_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x ${llvm_rhs_type}> undef, <vscale x 1 x ${llvm_result_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_vx = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, ${llvm_rhs_type}, <vscale x 1 x ${llvm_result_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, ${scalar_register}, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, ${llvm_rhs_type} undef, <vscale x 1 x ${llvm_result_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_vx_mask = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, ${llvm_rhs_type}, <vscale x 1 x ${llvm_result_type}>, <vscale x 1 x i1>);
define void @intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_mask_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, ${scalar_register}, v0, v0.t
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.mask.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, ${llvm_rhs_type} undef, <vscale x 1 x ${llvm_result_type}> undef, <vscale x 1 x i1> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(TernaryIntrinsic, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["vv"]:
            result = TernaryIntrinsic.pattern_vv
            if self.mask:
                result += TernaryIntrinsic.pattern_vv_mask
        elif variant in ["vx", "vf"]:
            result = TernaryIntrinsic.pattern_vx
            if self.mask:
                result += TernaryIntrinsic.pattern_vx_mask
        else:
            raise Exception("Unhandled variant '{}' for intrinsic '{}'".format(variant, intr.intr_name))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]
                rhs = intrinsic_type.operands[1]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["llvm_rhs_type"] = rhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                subs["value_rhs_type"] = rhs.value_type

                if v in ["vf", "wf"]:
                    subs["scalar_register"] = "ft0"
                elif v in ["vx", "wx"]:
                    subs["scalar_register"] = "a0"

                print template.substitute(subs)

class TernaryIntrinsicSwap(Intrinsic):
    pattern_vv = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, <vscale x 1 x ${llvm_rhs_type}>, <vscale x 1 x ${llvm_result_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, v0
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.nxv1${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, <vscale x 1 x ${llvm_rhs_type}> undef, <vscale x 1 x ${llvm_result_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_vx = """
declare <vscale x 1 x ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}>, ${llvm_rhs_type}, <vscale x 1 x ${llvm_result_type}>);
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, ${scalar_register}
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, ${llvm_rhs_type} undef, <vscale x 1 x ${llvm_result_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    pattern_vi = """
define void @intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}() nounwind {
entry:
; CHECK-LABEL: intrinsic_${intrinsic}_${suffix}_${value_result_type}_${value_lhs_type}_${value_rhs_type}
; CHECK:       ${instruction}.${suffix} v0, v0, 9
  %a = call <vscale x 1 x  ${llvm_result_type}> @llvm.epi.${intrinsic}.nxv1${value_result_type}.${value_rhs_type}(<vscale x 1 x ${llvm_lhs_type}> undef, ${llvm_rhs_type} 9, <vscale x 1 x ${llvm_result_type}> undef)
  %p = bitcast i8* @scratch to <vscale x 1 x ${llvm_result_type}>*
  store <vscale x 1 x ${llvm_result_type}> %a, <vscale x 1 x ${llvm_result_type}>* %p
  ret void
}
"""
    def __init__(self, intr_name, type_generator, **extra_info):
        super(TernaryIntrinsicSwap, self).__init__(intr_name, type_generator, **extra_info)

    def get_template(self, variant):
        result = ""
        if variant in ["vv"]:
            result = TernaryIntrinsicSwap.pattern_vv
            if self.mask:
                raise Exception("Template for 'vv' and mask not implemented")
        elif variant in ["vx", "vf"]:
            result = TernaryIntrinsicSwap.pattern_vx
            if self.mask:
                raise Exception("Template for 'vx/vf' and mask not implemented")
        elif variant in ["vi"]:
            result = TernaryIntrinsicSwap.pattern_vi
            if self.mask:
                raise Exception("Template for 'vi' and mask not implemented")
        else:
            raise Exception("Unhandled variant '{}' for intrinsic '{}'".format(variant, intr.intr_name))
        return string.Template(result)

    def render(self):
        for v in self.variants:
            template = self.get_template(v)

            op_subs = {}
            op_subs["intrinsic"] = self.intr_name
            op_subs["suffix"] = v
            for intrinsic_type in self.type_generator():
                result = intrinsic_type.result
                lhs = intrinsic_type.operands[0]
                rhs = intrinsic_type.operands[1]

                subs = op_subs.copy()
                subs["instruction"] = self.instruction
                subs["value_result_type"] = result.value_type
                subs["llvm_result_type"] = result.llvm_type

                subs["llvm_lhs_type"] = lhs.llvm_type
                subs["llvm_rhs_type"] = rhs.llvm_type
                subs["value_lhs_type"] = lhs.value_type
                subs["value_rhs_type"] = rhs.value_type

                if v in ["vf", "wf"]:
                    subs["scalar_register"] = "ft0"
                elif v in ["vx", "wx"]:
                    subs["scalar_register"] = "a0"

                print template.substitute(subs)

################################################################################
################################################################################
################################################################################

vv_vx_vi = ["vv", "vx", "vi"]
vv_vx = ["vv", "vx"]
wv_wx = ["wv", "wx"]
vx_vi = ["vx", "vi"]
vv_vf = ["vv", "vf"]
wv_wf = ["wv", "wf"]
vv = ["vv"]
vx = ["vx"]
vf = ["vf"]
vs = ["vs"]
mm = ["mm"]
vm = ["vm"]
m = ["m"]
v = ["v"]

################################################################################
################################################################################
################################################################################

intrinsics = [
        # FIXME: These return a scalar result!
        #UnaryIntrinsicScalarResult("vmpopc", type_generator = generate_mask_to_int_types, variants = m),
        #UnaryIntrinsicScalarResult("vmfirst", type_generator = generate_mask_to_int_types, variants = m),

        #UnaryIntrinsic("vfsqrt", type_generator = generate_unary_float_types, variants = v),
        # This is a very special one
        #UnaryIntrinsic("vfclass", type_generator = generate_unary_vfclass_types, variants = v),

        #UnaryIntrinsicScalarInput("vbroadcast", type_generator = generate_unary_integer_types, variants = vx, instruction = "vmerge", scalar_register = "a0"),
        #UnaryIntrinsicScalarInput("vbroadcast", type_generator = generate_unary_float_types, variants = vf, instruction = "vfmerge", scalar_register = "ft0"),

        #UnaryIntrinsicMask("vmsbf", type_generator = generate_unary_mask_types, variants = m),
        #UnaryIntrinsicMask("vmsof", type_generator = generate_unary_mask_types, variants = m),
        #UnaryIntrinsicMask("vmsif", type_generator = generate_unary_mask_types, variants = m),

        #UnaryIntrinsic("vmiota", type_generator = generate_unary_mask_to_integer_types, variants = m),

        #NullaryIntrinsic("vid", type_generator = generate_nullary_integer_types, variants = v),

        BinaryIntrinsic("vadd", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vsub", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vrsub", type_generator = generate_binary_integer_types, variants = vx_vi),

        BinaryIntrinsic("vwaddu", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),
        BinaryIntrinsic("vwadd", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),

        #BinaryIntrinsic("vwaddu.w", type_generator = generate_binary_integer_types_widened_lhs, variants = wv_wx),
        #BinaryIntrinsic("vwadd.w", type_generator = generate_binary_integer_types_widened_lhs, variants = wv_wx),

        BinaryIntrinsic("vwsubu", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),
        BinaryIntrinsic("vwsub", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),

        #BinaryIntrinsic("vwsubu.w", type_generator = generate_binary_integer_types_widened_lhs, variants = wv_wx),
        #BinaryIntrinsic("vwsub.w", type_generator = generate_binary_integer_types_widened_lhs, variants = wv_wx),

        BinaryIntrinsic("vand", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vor", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vxor", type_generator = generate_binary_integer_types, variants = vv_vx_vi),

        BinaryIntrinsic("vsll", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vsrl", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vsra", type_generator = generate_binary_integer_types, variants = vv_vx_vi),

        #BinaryIntrinsic("vnsrl", type_generator = generate_binary_integer_types_narrowed, variants = vv_vx_vi),
        #BinaryIntrinsic("vnsra", type_generator = generate_binary_integer_types_narrowed, variants = vv_vx_vi),

        BinaryIntrinsic("vseq", type_generator = generate_binary_integer_types_relational, variants = vv_vx_vi),
        BinaryIntrinsic("vsne", type_generator = generate_binary_integer_types_relational, variants = vv_vx_vi),
        BinaryIntrinsic("vsltu", type_generator = generate_binary_integer_types_relational, variants = vv_vx),
        BinaryIntrinsic("vslt", type_generator = generate_binary_integer_types_relational, variants = vv_vx),
        BinaryIntrinsic("vsleu", type_generator = generate_binary_integer_types_relational, variants = vv_vx_vi),
        BinaryIntrinsic("vsle", type_generator = generate_binary_integer_types_relational, variants = vv_vx_vi),
        BinaryIntrinsic("vsgtu", type_generator = generate_binary_integer_types_relational, variants = vx_vi),
        BinaryIntrinsic("vsgt", type_generator = generate_binary_integer_types_relational, variants = vx_vi),

        BinaryIntrinsic("vminu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmin", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmaxu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmax", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vmul", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmulh", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmulhu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vmulhsu", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vwmul", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),
        BinaryIntrinsic("vwmulu", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),
        BinaryIntrinsic("vwmulsu", type_generator = generate_binary_integer_types_widened, variants = vv_vx, vlmul_values = [1, 2, 4]),

        BinaryIntrinsic("vdivu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vdiv", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vremu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vrem", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vmerge", type_generator = generate_binary_integer_types, variants = vv_vx_vi),

        BinaryIntrinsic("vsaddu", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vsadd", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vssubu", type_generator = generate_binary_integer_types, variants = vv_vx),
        BinaryIntrinsic("vssub", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vaadd", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vasub", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vsmul", type_generator = generate_binary_integer_types, variants = vv_vx),

        BinaryIntrinsic("vssrl", type_generator = generate_binary_integer_types, variants = vv_vx_vi),
        BinaryIntrinsic("vssra", type_generator = generate_binary_integer_types, variants = vv_vx_vi),

        #BinaryIntrinsic("vnclipu", type_generator = generate_binary_integer_types_narrowed, variants = vv_vx_vi),
        #BinaryIntrinsic("vnclip", type_generator = generate_binary_integer_types_narrowed, variants = vv_vx_vi),

        BinaryIntrinsic("vfadd", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfsub", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfwadd", type_generator = generate_binary_float_types_widened, variants = vv_vf, vlmul_values = [1, 2, 4]),
        BinaryIntrinsic("vfwsub", type_generator = generate_binary_float_types_widened, variants = vv_vf, vlmul_values = [1, 2, 4]),

        #BinaryIntrinsic("vfwadd.w", type_generator = generate_binary_float_types_widened_lhs, variants = wv_wf),
        #BinaryIntrinsic("vfwsub.w", type_generator = generate_binary_float_types_widened_lhs, variants = wv_wf),

        BinaryIntrinsic("vfmul", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfdiv", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfrdiv", type_generator = generate_binary_float_types, variants = vf),

        BinaryIntrinsic("vfwmul", type_generator = generate_binary_float_types_widened, variants = vv_vf, vlmul_values = [1, 2, 4]),

        BinaryIntrinsic("vfmin", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfmax", type_generator = generate_binary_float_types, variants = vv_vf),

        BinaryIntrinsic("vfsgnj", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfsgnjn", type_generator = generate_binary_float_types, variants = vv_vf),
        BinaryIntrinsic("vfsgnjx", type_generator = generate_binary_float_types, variants = vv_vf),

        BinaryIntrinsic("vfeq", type_generator = generate_binary_float_types_relational, variants = vv_vf),
        BinaryIntrinsic("vfne", type_generator = generate_binary_float_types_relational, variants = vv_vf),
        BinaryIntrinsic("vflt", type_generator = generate_binary_float_types_relational, variants = vv_vf),
        BinaryIntrinsic("vfle", type_generator = generate_binary_float_types_relational, variants = vv_vf),
        BinaryIntrinsic("vfgt", type_generator = generate_binary_float_types_relational, variants = vf),
        BinaryIntrinsic("vfge", type_generator = generate_binary_float_types_relational, variants = vf),
        BinaryIntrinsic("vford", type_generator = generate_binary_float_types_relational, variants = vv_vf),

        BinaryIntrinsic("vfmerge", type_generator = generate_binary_float_types, variants = vv, instruction = "vmerge"),
        BinaryIntrinsic("vfmerge", type_generator = generate_binary_float_types, variants = vf),

        BinaryIntrinsic("vredsum", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredand", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredor", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredxor", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredminu", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredmin", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredmaxu", type_generator = generate_binary_integer_types, variants = vs),
        BinaryIntrinsic("vredmax", type_generator = generate_binary_integer_types, variants = vs),

        #BinaryIntrinsic("vwredsumu", type_generator = generate_binary_integer_types_widened, variants = vs),
        #BinaryIntrinsic("vwredsum", type_generator = generate_binary_integer_types_widened, variants = vs),

        BinaryIntrinsic("vfredsum", type_generator = generate_binary_float_types, variants = vs),
        BinaryIntrinsic("vfredosum", type_generator = generate_binary_float_types, variants = vs),
        BinaryIntrinsic("vfredmin", type_generator = generate_binary_float_types, variants = vs),
        BinaryIntrinsic("vfredmax", type_generator = generate_binary_float_types, variants = vs),

        #BinaryIntrinsic("vfwredsum", type_generator = generate_binary_float_types_widened, variants = vs),
        #BinaryIntrinsic("vfwredosum", type_generator = generate_binary_float_types_widened, variants = vs),

        #BinaryIntrinsic("vmandnot", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmand", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmor", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmxor", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmornot", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmnand", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmnor", type_generator = generate_binary_mask_types, variants = mm, mask = False),
        #BinaryIntrinsic("vmxnor", type_generator = generate_binary_mask_types, variants = mm, mask = False),

        BinaryIntrinsic("vdotu", type_generator = generate_binary_integer_types, variants = vv),
        BinaryIntrinsic("vdot", type_generator = generate_binary_integer_types, variants = vv),

        BinaryIntrinsic("vfdot", type_generator = generate_binary_float_types, variants = vv),

        #BinaryIntrinsic("vcompress", type_generator = generate_binary_any_and_mask_types, variants = vm, mask = False),

        #BinaryIntrinsic("vrgather", type_generator = generate_binary_any_and_integer_types, variants = vv_vx_vi),

        BinaryIntrinsic("vslideup", type_generator = generate_binary_any_and_integer_types, variants = vx_vi),
        BinaryIntrinsic("vslidedown", type_generator = generate_binary_any_and_integer_types, variants = vx_vi),
        #BinaryIntrinsic("vslide1up", type_generator = generate_binary_any_and_integer_types, variants = vx),
        #BinaryIntrinsic("vslide1down", type_generator = generate_binary_any_and_integer_types, variants = vx),

        #TernaryIntrinsicSwap("vadc", type_generator = generate_ternary_integer_types, variants = vv_vx_vi, mask = False),
        #TernaryIntrinsicSwap("vsbc", type_generator = generate_ternary_integer_types, variants = vv_vx, mask = False),

        #TernaryIntrinsic("vmacc", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vmsac", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vmadd", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vmsub", type_generator = generate_ternary_integer_types, variants = vv_vx),

        #TernaryIntrinsic("vwmaccu", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vwmacc", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vwmsacu", type_generator = generate_ternary_integer_types, variants = vv_vx),
        #TernaryIntrinsic("vwmsac", type_generator = generate_ternary_integer_types, variants = vv_vx),

        #TernaryIntrinsic("vfmadd", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfnmadd", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfmsub", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfnmsub", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfmacc", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfnmacc", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfmsac", type_generator = generate_ternary_float_types, variants = vv_vf),
        #TernaryIntrinsic("vfnmsac", type_generator = generate_ternary_float_types, variants = vv_vf),

        #TernaryIntrinsic("vfwmacc", type_generator = generate_ternary_float_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vfwnmacc", type_generator = generate_ternary_float_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vfwmsac", type_generator = generate_ternary_float_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vfwnmsac", type_generator = generate_ternary_float_types_widened, variants = vv_vx),

        #TernaryIntrinsic("vwsmaccu", type_generator = generate_ternary_integer_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vwsmacc", type_generator = generate_ternary_integer_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vwsmsacu", type_generator = generate_ternary_integer_types_widened, variants = vv_vx),
        #TernaryIntrinsic("vwsmsac", type_generator = generate_ternary_integer_types_widened, variants = vv_vx),

        #Conversion("vfcvt", type_generator = generate_same_size_float_to_integer_types, variants = ["xu.f"]),
        #Conversion("vfcvt", type_generator = generate_same_size_float_to_integer_types, variants = ["x.f"]),
        #Conversion("vfcvt", type_generator = generate_same_size_integer_to_float_types, variants = ["f.xu"]),
        #Conversion("vfcvt", type_generator = generate_same_size_integer_to_float_types, variants = ["f.x"]),

        #Conversion("vfwcvt.xu.f", type_generator = generate_widened_float_to_integer_types, variants = ["xu.f"],)
        #Conversion("vfwcvt.x.f", type_generator = generate_widened_float_to_integer_types, variants = ["x.f"], declare = False),
        #Conversion("vfwcvt.f.xu", type_generator = generate_widened_integer_to_float_types, variants = ["f.xu"]),
        #Conversion("vfwcvt.f.x", type_generator = generate_widened_integer_to_float_types, variants = ["f.x"], declare = False),
        #Conversion("vfwcvt", type_generator = generate_widened_float_to_float_types, variants = ["f.f"]),

        #Conversion("vfncvt.xu.f", type_generator = generate_narrow_float_to_integer_types, variants = [""]),
        #Conversion("vfncvt.x.f", type_generator = generate_narrow_float_to_integer_types, variants = [""]),
        #Conversion("vfncvt.f.xu", type_generator = generate_narrow_integer_to_float_types, variants = [""]),
        #Conversion("vfncvt.f.x", type_generator = generate_narrow_integer_to_float_types, variants = [""]),
        #Conversion("vfncvt", type_generator = generate_narrow_float_to_float_types, variants = ["f.f"])
]

for intr in intrinsics:
    intr.render()
