//===- llvm/Analysis/OmpSsRegionAnalysis.h - OmpSs Region Analysis -*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
#ifndef LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H
#define LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H

#include "llvm/IR/PassManager.h"
#include "llvm/Pass.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/IR/Dominators.h"
#include "llvm/IR/IntrinsicInst.h"

namespace llvm {

// Data-sharing lists.
struct DirectiveDSAInfo {
  SetVector<Value *> Shared;
  SetVector<Value *> Private;
  SetVector<Value *> Firstprivate;
};

// <VLA, VLA_dims>
using DirectiveVLADimsInfo = MapVector<Value *, SetVector<Value *>>;
// Captures lists.
using DirectiveCapturedInfo = SetVector<Value *>;

// Non-POD stuff
using DirectiveInits = MapVector<Value *, Value *>;
using DirectiveDeinits = MapVector<Value *, Value *>;
using DirectiveCopies = MapVector<Value *, Value *>;

struct DirectiveNonPODsInfo {
  DirectiveInits Inits;
  DirectiveDeinits Deinits;
  DirectiveCopies Copies;
};

struct DependInfo {
  enum DependType {
    DT_in = 0,
    DT_out,
    DT_inout,
    DT_concurrent,
    DT_commutative,
    DT_reduction,
    DT_weakin,
    DT_weakout,
    DT_weakinout,
    DT_weakconcurrent,
    DT_weakcommutative,
    DT_weakreduction,
    DT_unknown,
  };

  enum DependKind {
    DK_single,
    DK_multi,
  };

  DependType DepType = DT_unknown;
  DependKind DepKind = DK_single;
  // Used only in DT_reduction and DT_weakreduction
  Value *RedKind = nullptr;
  // Dependency base.
  Value *Base = nullptr;
  // compute_dep function that returns all the dependency needed info.
  Function *ComputeDepFun = nullptr;
  // The arguments of the call to compute_dep function.
  SmallVector<Value *, 4> Args;
  // Dependencies over the same symbol share the same index.
  int SymbolIndex = -1;
  // User written dependency as string. Generated by clang
  StringRef RegionText;

  DependInfo() {}
  DependInfo(DependKind Kind)
    : DepKind(Kind)
    {}
  virtual ~DependInfo() {}

  DependKind getDependKind() const { return DepKind; }

  bool isReduction() const {
    return DepType == DT_reduction ||
      DepType == DT_weakreduction;
  }

  static bool classof(const DependInfo *DI) {
    return DI->getDependKind() == DK_single;
  }
};

struct MultiDependInfo : public DependInfo {
  // List of iterators of the multidep.
  SmallVector<Value *, 4> Iters;
  // Function that returns the iterator init/ub/step info.
  // Used to build the multidep loop.
  Function *ComputeMultiDepFun = nullptr;
  // Arguments to call ComputeMultiDepFun.
  SmallVector<Value *, 4> Args;

  MultiDependInfo()
    : DependInfo(DK_multi)
    {}

  static bool classof(const DependInfo *DI) {
    return DI->getDependKind() == DK_multi;
  }
};

struct DirectiveDependsInfo {
  // List of all found dependencies/multidependencies/reductions...
  SmallVector<std::unique_ptr<DependInfo>, 4> List;
  // The amount of different symbols used by dependencies
  // in a directive.
  int NumSymbols = 0;
};

struct ReductionInitCombInfo {
  Value *Init;
  Value *Comb;
  // This is used to index the array of
  // init/combiners
  int ReductionIndex;
};

using DirectiveReductionsInitCombInfo = MapVector<Value *, ReductionInitCombInfo>;

struct DirectiveLoopInfo {
  enum {
    LT, // <
    LE, // <=
    GT, // >
    GE, // >=
  };
  // The type of the loop to build. (i.e. LT, LE,...)
  int64_t LoopType = -1;
  // Signedness of the induction var.
  int64_t IndVarSigned = -1;
  // Signedness of the lower bound.
  int64_t LBoundSigned = -1;
  // Signedness of the upper bound.
  int64_t UBoundSigned = -1;
  // Signedness of the step.
  int64_t StepSigned = -1;
  Value *IndVar = nullptr;
  Value *LBound = nullptr;
  Value *UBound = nullptr;
  Value *Step = nullptr;
  Value *Chunksize = nullptr;
  Value *Grainsize = nullptr;
  bool empty() const {
    return !IndVar && !LBound &&
           !UBound && !Step &&
           LoopType == -1 && IndVarSigned == -1 &&
           LBoundSigned == -1 && UBoundSigned == -1;
  }
};

struct DirectiveEnvironment {
  enum OmpSsDirectiveKind {
    OSSD_task = 0,
    OSSD_task_for,
    OSSD_taskloop,
    OSSD_taskloop_for,
    OSSD_taskwait,
    OSSD_release,
    OSSD_unknown
  };
  OmpSsDirectiveKind DirectiveKind = OSSD_unknown;
  StringRef DirectiveKindStringRef;
  DirectiveDSAInfo DSAInfo;
  DirectiveVLADimsInfo VLADimsInfo;
  DirectiveDependsInfo DependsInfo;
  DirectiveReductionsInitCombInfo ReductionsInitCombInfo;
  Value *Final = nullptr;
  Value *If = nullptr;
  Value *Priority = nullptr;
  Value *Label = nullptr;
  Value *Cost = nullptr;
  Value *Wait = nullptr;
  DirectiveCapturedInfo CapturedInfo;
  DirectiveNonPODsInfo NonPODsInfo;
  DirectiveLoopInfo LoopInfo;
  DirectiveEnvironment(const Instruction *I);
  // Different reductions may have same init/comb, assign the same ReductionIndex
  DenseMap<Value *, int> SeenInits;
  int ReductionIndex = 0;
  // Map of Dependency symbols to Index
  std::map<Value *, int> DepSymToIdx;
private:
  void gatherDirInfo(OperandBundleDef &OBDef);
  void gatherSharedInfo(OperandBundleDef &OBDef);
  void gatherPrivateInfo(OperandBundleDef &OBDef);
  void gatherFirstprivateInfo(OperandBundleDef &OBDef);
  void gatherVLADimsInfo(OperandBundleDef &OBDef);
  void gatherDependInfo(OperandBundleDef &OBDef, uint64_t Id);
  void gatherReductionInitInfo(OperandBundleDef &OBDef);
  void gatherReductionCombInfo(OperandBundleDef &OBDef);
  void gatherFinalInfo(OperandBundleDef &OBDef);
  void gatherIfInfo(OperandBundleDef &OBDef);
  void gatherCostInfo(OperandBundleDef &OBDef);
  void gatherPriorityInfo(OperandBundleDef &OBDef);
  void gatherLabelInfo(OperandBundleDef &OBDef);
  void gatherWaitInfo(OperandBundleDef &OBDef);
  void gatherCapturedInfo(OperandBundleDef &OBDef);
  void gatherNonPODInitInfo(OperandBundleDef &OBDef);
  void gatherNonPODDeinitInfo(OperandBundleDef &OBDef);
  void gatherNonPODCopyInfo(OperandBundleDef &OBDef);
  void gatherLoopTypeInfo(OperandBundleDef &OBDef);
  void gatherLoopIndVarInfo(OperandBundleDef &OBDef);
  void gatherLoopLowerBoundInfo(OperandBundleDef &OBDef);
  void gatherLoopUpperBoundInfo(OperandBundleDef &OBDef);
  void gatherLoopStepInfo(OperandBundleDef &OBDef);
  void gatherLoopChunksizeInfo(OperandBundleDef &OBDef);
  void gatherLoopGrainsizeInfo(OperandBundleDef &OBDef);
  void gatherMultiDependInfo(OperandBundleDef &OBDef, uint64_t Id);

  void verifyVLADimsInfo();
  void verifyDependInfo();
  void verifyReductionInitCombInfo();
  void verifyNonPODInfo();
  void verifyLoopInfo();
  void verifyMultiDependInfo();

public:
  void verify();
  // returns the directive kind string found in bundles.
  StringRef getDirectiveNameAsStr() const {
    return DirectiveKindStringRef;
  }
  // returns if directive is
  // task for, taskloop, taskloop for
  bool isOmpSsLoopDirective() const {
    return DirectiveKind == OSSD_task_for ||
           DirectiveKind == OSSD_taskloop ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // taskloop, taskloop for
  bool isOmpSsTaskLoopDirective() const {
    return DirectiveKind == OSSD_taskloop ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // task for, taskloop for
  bool isOmpSsTaskForDirective() const {
    return DirectiveKind == OSSD_task_for ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // task, task for, taskloop, taskloop for
  bool isOmpSsTaskDirective() const {
    return DirectiveKind == OSSD_task || isOmpSsLoopDirective();
  }
  // returns if directive is release
  bool isOmpSsReleaseDirective() const {
    return DirectiveKind == OSSD_release;
  }
  // returns if directive is taskwait
  bool isOmpSsTaskwaitDirective() const {
    return DirectiveKind == OSSD_taskwait;
  }
};

struct DirectiveInfo {
  // The intrinsic region.entry or the directive.marker.
  Instruction *Entry = nullptr;
  // The intrinsic region.exit.
  Instruction *Exit = nullptr;
  // Used to lower directives in final context.
  // Used to build loops of taskloop/taskfor.
  SmallVector<DirectiveInfo *, 4> InnerDirectiveInfos;
  // The environment of the directive. (clauses).
  DirectiveEnvironment DirEnv;
  DirectiveInfo(Instruction *Entry)
    : Entry(Entry), DirEnv(Entry)
    {}
  DirectiveInfo(Instruction *Entry, Instruction *Exit)
    : Entry(Entry), Exit(Exit), DirEnv(Entry)
    {}
};

// All the directives found in post order.
struct DirectiveFunctionInfo {
  SmallVector<DirectiveInfo *, 4> PostOrder;
};

// Analysis info to check that directives are single entry
// single exit
struct DirectiveAnalysisInfo {
  SetVector<Value *> UsesBeforeEntry;
  SetVector<Value *> UsesAfterExit;
};

class OmpSsRegionAnalysisPass : public FunctionPass {
private:

  // Directive Analysis for a directive entry.
  MapVector<Instruction *, DirectiveAnalysisInfo> DEntryToDAnalysisInfo;
  // Directive Info for a directive entry.
  MapVector<Instruction *, std::unique_ptr<DirectiveInfo>> DEntryToDInfo;
  // Directive layout in a tree form.
  // nullptr is the first level where the outer tasks are.
  MapVector<Instruction *, SmallVector<Instruction *, 4>> DirectivesTree;

  // Info used by the transform pass.
  DirectiveFunctionInfo DirectiveFuncInfo;

  static const int PrintSpaceMultiplier = 2;

  // Prints the directive layout with additional info.
  void print_verbose(Instruction *Cur, int Depth, int PrintSpaceMultiplier) const;

  // Converts DirectiveTree into a post order directive list. Convenience function
  void convertDirectivesTreeToVectorImpl(
    Instruction *Cur, SmallVectorImpl<Instruction *> &Stack);
  // Converts DirectiveTree into a post order directive list.
  void convertDirectivesTreeToVector();
  // Walk over each task in RPO identifying uses before entry
  // and after exit. Uses before task entry are then matched with DSA info
  // or Captured info from OperandBundles
  void getOmpSsFunctionInfo(Function &F, DominatorTree &DT);

public:
  static char ID;

  OmpSsRegionAnalysisPass();

  bool runOnFunction(Function &F) override;

  StringRef getPassName() const override { return "OmpSs-2 Region Analysis"; }

  void getAnalysisUsage(AnalysisUsage &AU) const override;

  void print(raw_ostream &OS, const Module *M) const override;

  void releaseMemory() override;

  DirectiveFunctionInfo& getFuncInfo();

};

} // end namespace llvm

#endif // LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H

