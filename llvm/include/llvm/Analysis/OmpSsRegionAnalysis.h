//===- llvm/Analysis/OmpSsRegionAnalysis.h - OmpSs Region Analysis -*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H
#define LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H

#include "llvm/IR/PassManager.h"
#include "llvm/Pass.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/IR/Dominators.h"
#include "llvm/IR/IntrinsicInst.h"

#include <map>

namespace llvm {

// Data-sharing lists.
struct DirectiveDSAInfo {
  SetVector<Value *> Shared;
  SetVector<Value *> Private;
  SetVector<Value *> Firstprivate;
  SmallVector<Type *, 4> SharedTy;
  SmallVector<Type *, 4> PrivateTy;
  SmallVector<Type *, 4> FirstprivateTy;
};

// <VLA, VLA_dims>
using DirectiveVLADimsInfo = MapVector<Value *, SetVector<Value *>>;
// Captures lists.
using DirectiveCapturedInfo = SetVector<Value *>;

// Non-POD stuff
using DirectiveInits = MapVector<Value *, Value *>;
using DirectiveDeinits = MapVector<Value *, Value *>;
using DirectiveCopies = MapVector<Value *, Value *>;

struct DirectiveNonPODsInfo {
  DirectiveInits Inits;
  DirectiveDeinits Deinits;
  DirectiveCopies Copies;
};

struct DependInfo {
  enum DependType {
    DT_in = 0,
    DT_out,
    DT_inout,
    DT_concurrent,
    DT_commutative,
    DT_reduction,
    DT_weakin,
    DT_weakout,
    DT_weakinout,
    DT_weakconcurrent,
    DT_weakcommutative,
    DT_weakreduction,
    DT_unknown,
  };

  enum DependKind {
    DK_single,
    DK_multi,
  };

  DependType DepType = DT_unknown;
  DependKind DepKind = DK_single;
  // Used only in DT_reduction and DT_weakreduction
  Value *RedKind = nullptr;
  // Dependency base.
  Value *Base = nullptr;
  // compute_dep function that returns all the dependency needed info.
  Function *ComputeDepFun = nullptr;
  // The arguments of the call to compute_dep function.
  SmallVector<Value *, 4> Args;
  // Dependencies over the same symbol share the same index.
  int SymbolIndex = -1;
  // User written dependency as string. Generated by clang
  StringRef RegionText;

  DependInfo() {}
  DependInfo(DependKind Kind)
    : DepKind(Kind)
    {}
  virtual ~DependInfo() {}

  DependKind getDependKind() const { return DepKind; }

  bool isReduction() const {
    return DepType == DT_reduction ||
      DepType == DT_weakreduction;
  }

  static bool classof(const DependInfo *DI) {
    return DI->getDependKind() == DK_single;
  }
};

struct MultiDependInfo : public DependInfo {
  // List of iterators of the multidep.
  SmallVector<Value *, 4> Iters;
  // Function that returns the iterator init/ub/step info.
  // Used to build the multidep loop.
  Function *ComputeMultiDepFun = nullptr;
  // Arguments to call ComputeMultiDepFun.
  SmallVector<Value *, 4> Args;

  MultiDependInfo()
    : DependInfo(DK_multi)
    {}

  static bool classof(const DependInfo *DI) {
    return DI->getDependKind() == DK_multi;
  }
};

struct DirectiveDependsInfo {
  // List of all found dependencies/multidependencies/reductions...
  SmallVector<std::unique_ptr<DependInfo>, 4> List;
  // The amount of different symbols used by dependencies
  // in a directive.
  int NumSymbols = 0;
};

struct ReductionInitCombInfo {
  Value *Init;
  Value *Comb;
  // This is used to index the array of
  // init/combiners
  int ReductionIndex;
};

using DirectiveReductionsInitCombInfo = MapVector<Value *, ReductionInitCombInfo>;

struct DirectiveCostInfo {
  Function *Fun = nullptr;
  // The arguments of the call to function.
  SmallVector<Value *, 4> Args;
};

struct DirectivePriorityInfo {
  Function *Fun = nullptr;
  // The arguments of the call to function.
  SmallVector<Value *, 4> Args;
};

struct DirectiveOnreadyInfo {
  Function *Fun = nullptr;
  // The arguments of the call to function.
  SmallVector<Value *, 4> Args;
};

struct DirectiveDeviceInfo {
  Value *Kind = nullptr;
  // The arguments of the call to function.
  size_t NumDims = 0;
  SmallVector<Value *, 4> Ndrange;
  bool HasLocalSize = true;
  StringRef DevFuncStringRef;
  bool empty() const {
    // Not set or set to smp â†’ 0
    return !Kind
      || cast<ConstantInt>(Kind)->getSExtValue() == 0;
  }
};

struct DirectiveLoopInfo {
  enum {
    LT, // <
    LE, // <=
    GT, // >
    GE, // >=
  };
  struct BoundInfo {
    Function *Fun = nullptr;
    // The arguments of the call to function.
    SmallVector<Value *, 4> Args;
    // Used by transformation to store the result value
    mutable Value *Result = nullptr;
  };

  // The type of the loop to build. (i.e. LT, LE,...)
  SmallVector<int64_t> LoopType;
  // Signedness of the induction var.
  SmallVector<int64_t> IndVarSigned;
  // Signedness of the lower bound.
  SmallVector<int64_t> LBoundSigned;
  // Signedness of the upper bound.
  SmallVector<int64_t> UBoundSigned;
  // Signedness of the step.
  SmallVector<int64_t> StepSigned;
  SmallVector<Value *> IndVar;
  SmallVector<BoundInfo> LBound;
  SmallVector<BoundInfo> UBound;
  SmallVector<BoundInfo> Step;
  Value *Chunksize = nullptr;
  Value *Grainsize = nullptr;
  Value *Unroll = nullptr;
  Value *Update = nullptr;
  bool empty() const {
    return IndVar.empty() && LBound.empty() &&
           UBound.empty() && Step.empty() &&
           LoopType.empty() && IndVarSigned.empty() &&
           LBoundSigned.empty() && UBoundSigned.empty();
  }
};

struct DirectiveWhileInfo {
  Function *Fun = nullptr;
  // The arguments of the call to function.
  SmallVector<Value *, 4> Args;
  // Used by transformation to store the result value
  mutable Value *Result = nullptr;
  bool empty() const { return !Fun && Args.empty(); };
};

struct DirectiveEnvironment {
  enum OmpSsDirectiveKind {
    OSSD_task = 0,
    OSSD_critical_start,
    OSSD_critical_end,
    OSSD_task_for,
    OSSD_taskiter_for,
    OSSD_taskiter_while,
    OSSD_taskloop,
    OSSD_taskloop_for,
    OSSD_taskwait,
    OSSD_release,
    OSSD_unknown
  };
  OmpSsDirectiveKind DirectiveKind = OSSD_unknown;
  StringRef CriticalNameStringRef;
  StringRef DirectiveKindStringRef;
  DirectiveDSAInfo DSAInfo;
  DirectiveVLADimsInfo VLADimsInfo;
  DirectiveDependsInfo DependsInfo;
  DirectiveReductionsInitCombInfo ReductionsInitCombInfo;
  DirectiveCostInfo CostInfo;
  DirectivePriorityInfo PriorityInfo;
  DirectiveOnreadyInfo OnreadyInfo;
  Value *Final = nullptr;
  Value *If = nullptr;
  Value *Label = nullptr;
  Value *InstanceLabel = nullptr;
  Value *Wait = nullptr;
  DirectiveDeviceInfo DeviceInfo;
  DirectiveCapturedInfo CapturedInfo;
  DirectiveNonPODsInfo NonPODsInfo;
  DirectiveLoopInfo LoopInfo;
  // Used in taskiter (while)
  DirectiveWhileInfo WhileInfo;
  StringRef DeclSourceStringRef;
  DirectiveEnvironment(const Instruction *I);
  // Different reductions may have same init/comb, assign the same ReductionIndex
  DenseMap<Value *, int> SeenInits;
  int ReductionIndex = 0;
  // Map of Dependency symbols to Index
  std::map<Value *, int> DepSymToIdx;

  // returns if V is in DSAInfo
  bool valueInDSABundles(const Value *V) const {
    auto SharedIt = find(DSAInfo.Shared, V);
    auto PrivateIt = find(DSAInfo.Private, V);
    auto FirstprivateIt = find(DSAInfo.Firstprivate, V);
    if (SharedIt == DSAInfo.Shared.end()
        && PrivateIt == DSAInfo.Private.end()
        && FirstprivateIt == DSAInfo.Firstprivate.end())
      return false;

    return true;
  }

  // returns if the associated type of V
  Type *getDSAType(const Value *V) const {
    for (size_t i = 0; i < DSAInfo.Shared.size(); ++i)
      if (DSAInfo.Shared[i] == V)
        return DSAInfo.SharedTy[i];
    for (size_t i = 0; i < DSAInfo.Private.size(); ++i)
      if (DSAInfo.Private[i] == V)
        return DSAInfo.PrivateTy[i];
    for (size_t i = 0; i < DSAInfo.Firstprivate.size(); ++i)
      if (DSAInfo.Firstprivate[i] == V)
        return DSAInfo.FirstprivateTy[i];
    llvm_unreachable("Expected Value to be in DSAInfo");
  }

  // returns if V is in CapturedInfo
  bool valueInCapturedBundle(Value *const V) const {
    return CapturedInfo.count(V);
  }

private:
  void gatherDirInfo(OperandBundleDef &OBDef);
  void gatherSharedInfo(OperandBundleDef &OBDef);
  void gatherPrivateInfo(OperandBundleDef &OBDef);
  void gatherFirstprivateInfo(OperandBundleDef &OBDef);
  void gatherVLADimsInfo(OperandBundleDef &OBDef);
  void gatherDependInfo(OperandBundleDef &OBDef, uint64_t Id);
  void gatherReductionInitInfo(OperandBundleDef &OBDef);
  void gatherReductionCombInfo(OperandBundleDef &OBDef);
  void gatherFinalInfo(OperandBundleDef &OBDef);
  void gatherIfInfo(OperandBundleDef &OBDef);
  void gatherCostInfo(OperandBundleDef &OBDef);
  void gatherPriorityInfo(OperandBundleDef &OBDef);
  void gatherLabelInfo(OperandBundleDef &OBDef);
  void gatherOnreadyInfo(OperandBundleDef &OBDef);
  void gatherWaitInfo(OperandBundleDef &OBDef);
  void gatherDeviceInfo(OperandBundleDef &OBDef);
  void gatherDeviceNdrangeInfo(OperandBundleDef &OBDef);
  void gatherDeviceDevFuncInfo(OperandBundleDef &OBDef);
  void gatherCapturedInfo(OperandBundleDef &OBDef);
  void gatherNonPODInitInfo(OperandBundleDef &OBDef);
  void gatherNonPODDeinitInfo(OperandBundleDef &OBDef);
  void gatherNonPODCopyInfo(OperandBundleDef &OBDef);
  void gatherLoopTypeInfo(OperandBundleDef &OBDef);
  void gatherLoopIndVarInfo(OperandBundleDef &OBDef);
  void gatherLoopLowerBoundInfo(OperandBundleDef &OBDef);
  void gatherLoopUpperBoundInfo(OperandBundleDef &OBDef);
  void gatherLoopStepInfo(OperandBundleDef &OBDef);
  void gatherLoopChunksizeInfo(OperandBundleDef &OBDef);
  void gatherLoopGrainsizeInfo(OperandBundleDef &OBDef);
  void gatherLoopUnrollInfo(OperandBundleDef &OBDef);
  void gatherLoopUpdateInfo(OperandBundleDef &OBDef);
  void gatherWhileCondInfo(OperandBundleDef &OBDef);
  void gatherMultiDependInfo(OperandBundleDef &OBDef, uint64_t Id);
  void gatherDeclSource(OperandBundleDef &OBDef);

  void verifyVLADimsInfo();
  void verifyDependInfo();
  void verifyReductionInitCombInfo();
  void verifyCostInfo();
  void verifyPriorityInfo();
  void verifyOnreadyInfo();
  void verifyDeviceInfo();
  void verifyNonPODInfo();
  void verifyLoopInfo();
  void verifyWhileInfo();
  void verifyMultiDependInfo();
  void verifyLabelInfo();

public:
  void verify();
  // returns the directive kind string found in bundles.
  StringRef getDirectiveNameAsStr() const {
    return DirectiveKindStringRef;
  }
  // returns if directive is
  // task for, taskloop, taskloop for
  bool isOmpSsLoopDirective() const {
    return DirectiveKind == OSSD_task_for ||
           DirectiveKind == OSSD_taskloop ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // taskloop, taskloop for
  bool isOmpSsTaskLoopDirective() const {
    return DirectiveKind == OSSD_taskloop ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // task for, taskloop for
  bool isOmpSsTaskForDirective() const {
    return DirectiveKind == OSSD_task_for ||
           DirectiveKind == OSSD_taskloop_for;
  }
  // returns if directive is
  // taskiter (for|while)
  bool isOmpSsTaskIterDirective() const {
    return DirectiveKind == OSSD_taskiter_for ||
           DirectiveKind == OSSD_taskiter_while;
  }
  // returns if directive is
  // taskiter for
  bool isOmpSsTaskIterForDirective() const {
    return DirectiveKind == OSSD_taskiter_for;
  }
  // returns if directive is
  // taskiter while
  bool isOmpSsTaskIterWhileDirective() const {
    return DirectiveKind == OSSD_taskiter_while;
  }
  // returns if directive is
  // task, task for, taskloop, taskloop for
  bool isOmpSsTaskDirective() const {
    return DirectiveKind == OSSD_task ||
           isOmpSsLoopDirective() ||
           isOmpSsTaskIterDirective();
  }
  // returns if directive is critical
  bool isOmpSsCriticalStartDirective() const {
    return DirectiveKind == OSSD_critical_start;
  }
  // returns if directive is critical
  bool isOmpSsCriticalEndDirective() const {
    return DirectiveKind == OSSD_critical_end;
  }
  // returns if directive is critical
  bool isOmpSsCriticalDirective() const {
    return isOmpSsCriticalStartDirective() ||
           isOmpSsCriticalEndDirective();
  }
  // returns if directive is release
  bool isOmpSsReleaseDirective() const {
    return DirectiveKind == OSSD_release;
  }
  // returns if directive is taskwait
  bool isOmpSsTaskwaitDirective() const {
    return DirectiveKind == OSSD_taskwait;
  }
};

struct DirectiveInfo {
  // The intrinsic region.entry or the directive.marker.
  Instruction *Entry = nullptr;
  // The intrinsic region.exit.
  Instruction *Exit = nullptr;
  // Used to lower directives in final context.
  // Used to build loops of taskloop/taskfor.
  SmallVector<DirectiveInfo *, 4> InnerDirectiveInfos;
  // The environment of the directive. (clauses).
  DirectiveEnvironment DirEnv;
  DirectiveInfo(Instruction *Entry)
    : Entry(Entry), DirEnv(Entry)
    {}
  DirectiveInfo(Instruction *Entry, Instruction *Exit)
    : Entry(Entry), Exit(Exit), DirEnv(Entry)
    {}
};

// All the directives found in post order.
struct DirectiveFunctionInfo {
  SmallVector<DirectiveInfo *, 4> PostOrder;
};

// Analysis info to check that directives are single entry
// single exit
struct DirectiveAnalysisInfo {
  SetVector<Value *> UsesBeforeEntry;
  SetVector<Value *> UsesAfterExit;
};

// This is used in both old and new pass managers
class OmpSsRegionAnalysis {
  // Directive Analysis for a directive entry.
  MapVector<Instruction *, DirectiveAnalysisInfo> DEntryToDAnalysisInfo;
  // Directive Info for a directive entry.
  MapVector<Instruction *, std::unique_ptr<DirectiveInfo>> DEntryToDInfo;
  // Directive layout in a tree form.
  // nullptr is the first level where the outer tasks are.
  MapVector<Instruction *, SmallVector<Instruction *, 4>> DirectivesTree;

  // Info used by the transform pass.
  DirectiveFunctionInfo DirectiveFuncInfo;

  static const int PrintSpaceMultiplier = 2;

  // Prints the directive layout with additional info.
  void print_verbose(Instruction *Cur, int Depth, int PrintSpaceMultiplier) const;

  // Converts DirectiveTree into a post order directive list. Convenience function
  void convertDirectivesTreeToVectorImpl(
    Instruction *Cur, SmallVectorImpl<Instruction *> &Stack);
  // Converts DirectiveTree into a post order directive list.
  void convertDirectivesTreeToVector();
public:
  // Walk over each task in RPO identifying uses before entry
  // and after exit. Uses before task entry are then matched with DSA info
  // or Captured info from OperandBundles
  OmpSsRegionAnalysis(Function &F, DominatorTree &DT);
  // Default ctor to clean all stuff and be ready for the next analysis.
  OmpSsRegionAnalysis() = default;

  void print(raw_ostream &OS) const;
  DirectiveFunctionInfo &getFuncInfo();
};

// Old/Legacy PassManager Analysis/Printer
class OmpSsRegionAnalysisLegacyPass : public FunctionPass {
  OmpSsRegionAnalysis ORA;
public:
  static char ID;

  OmpSsRegionAnalysisLegacyPass();

  bool runOnFunction(Function &F) override;

  StringRef getPassName() const override { return "OmpSs-2 Region Analysis"; }

  void getAnalysisUsage(AnalysisUsage &AU) const override;

  void print(raw_ostream &OS, const Module *M) const override;

  void releaseMemory() override;

  OmpSsRegionAnalysis& getResult();
};

// New PassManager Analysis
class OmpSsRegionAnalysisPass : public AnalysisInfoMixin<OmpSsRegionAnalysisPass> {
  friend AnalysisInfoMixin<OmpSsRegionAnalysisPass>;

  static AnalysisKey Key;

public:
  /// Provide the result typedef for this analysis pass.
  using Result = OmpSsRegionAnalysis;

  OmpSsRegionAnalysis run(Function &F, FunctionAnalysisManager &FAM);
};

// New PassManager Printer
class OmpSsRegionPrinterPass
    : public PassInfoMixin<OmpSsRegionPrinterPass> {
  raw_ostream &OS;

public:
  explicit OmpSsRegionPrinterPass(raw_ostream &OS);

  PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM);
};

} // end namespace llvm

#endif // LLVM_ANALYSIS_OMPSSREGIONANALYSIS_H

