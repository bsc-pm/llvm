; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
; RUN: opt %s -passes=ompss-2 -S | FileCheck %s
; ModuleID = 'task_for_cond_and_register_check.ll'
source_filename = "task_for_cond_and_register_check.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; void signed_loop_slt(int lb, int ub, int step) {
;     #pragma oss task for
;     for (int i = lb; i < ub; i += step) {}
; }
; void signed_loop_sle(int lb, int ub, int step) {
;     #pragma oss task for
;     for (int i = lb; i <= ub; i += step) {}
; }
; void signed_loop_sgt(int lb, int ub, int step) {
;     #pragma oss task for
;     for (int i = ub; i > lb; i -= step) {}
; }
; void signed_loop_sge(int lb, int ub, int step) {
;     #pragma oss task for
;     for (int i = ub; i >= lb; i -= step) {}
; }
; void unsigned_loop_slt(unsigned lb, unsigned ub, unsigned step) {
;     #pragma oss task for
;     for (unsigned i = lb; i < ub; i += step) {}
; }
; void unsigned_loop_sle(unsigned lb, unsigned ub, unsigned step) {
;     #pragma oss task for
;     for (unsigned i = lb; i <= ub; i += step) {}
; }
; void unsigned_loop_sgt(unsigned lb, unsigned ub, unsigned step) {
;     #pragma oss task for
;     for (unsigned i = ub; i > lb; i -= step) {}
; }
; void unsigned_loop_sge(unsigned lb, unsigned ub, unsigned step) {
;     #pragma oss task for
;     for (unsigned i = ub; i >= lb; i -= step) {}
; }
; void constants_loop() {
;     #pragma oss task for
;     for (int i = 0; i < 10; i += 1) {}
; }

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z15signed_loop_sltiii(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !5 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %lb.addr, align 4, !dbg !9
  store i32 %0, ptr %i, align 4, !dbg !10
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb, ptr %lb.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub, ptr %ub.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 1, i64 1, i64 1, i64 1) ], !dbg !11
  call void @llvm.directive.region.exit(token %1), !dbg !12
  ret void, !dbg !13
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

define internal i32 @compute_lb(ptr %lb) #2 !dbg !14 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !15
  ret i32 %0, !dbg !15
}

define internal i32 @compute_ub(ptr %ub) #2 !dbg !17 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !18
  ret i32 %0, !dbg !18
}

define internal i32 @compute_step(ptr %step) #2 !dbg !20 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !21
  ret i32 %0, !dbg !21
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z15signed_loop_sleiii(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !23 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %lb.addr, align 4, !dbg !24
  store i32 %0, ptr %i, align 4, !dbg !25
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.1, ptr %lb.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.2, ptr %ub.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.3, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 1, i64 1, i64 1, i64 1, i64 1) ], !dbg !26
  call void @llvm.directive.region.exit(token %1), !dbg !27
  ret void, !dbg !28
}

define internal i32 @compute_lb.1(ptr %lb) #2 !dbg !29 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !30
  ret i32 %0, !dbg !30
}

define internal i32 @compute_ub.2(ptr %ub) #2 !dbg !32 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !33
  ret i32 %0, !dbg !33
}

define internal i32 @compute_step.3(ptr %step) #2 !dbg !35 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !36
  ret i32 %0, !dbg !36
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z15signed_loop_sgtiii(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !38 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %ub.addr, align 4, !dbg !39
  store i32 %0, ptr %i, align 4, !dbg !40
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.4, ptr %ub.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.5, ptr %lb.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.6, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 2, i64 1, i64 1, i64 1, i64 1) ], !dbg !41
  call void @llvm.directive.region.exit(token %1), !dbg !42
  ret void, !dbg !43
}

define internal i32 @compute_lb.4(ptr %ub) #2 !dbg !44 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !45
  ret i32 %0, !dbg !45
}

define internal i32 @compute_ub.5(ptr %lb) #2 !dbg !47 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !48
  ret i32 %0, !dbg !48
}

define internal i32 @compute_step.6(ptr %step) #2 !dbg !50 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !51
  %sub = sub nsw i32 0, %0, !dbg !51
  ret i32 %sub, !dbg !51
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z15signed_loop_sgeiii(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !53 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %ub.addr, align 4, !dbg !54
  store i32 %0, ptr %i, align 4, !dbg !55
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.7, ptr %ub.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.8, ptr %lb.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.9, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 3, i64 1, i64 1, i64 1, i64 1) ], !dbg !56
  call void @llvm.directive.region.exit(token %1), !dbg !57
  ret void, !dbg !58
}

define internal i32 @compute_lb.7(ptr %ub) #2 !dbg !59 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !60
  ret i32 %0, !dbg !60
}

define internal i32 @compute_ub.8(ptr %lb) #2 !dbg !62 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !63
  ret i32 %0, !dbg !63
}

define internal i32 @compute_step.9(ptr %step) #2 !dbg !65 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !66
  %sub = sub nsw i32 0, %0, !dbg !66
  ret i32 %sub, !dbg !66
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z17unsigned_loop_sltjjj(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !68 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %lb.addr, align 4, !dbg !69
  store i32 %0, ptr %i, align 4, !dbg !70
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.10, ptr %lb.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.11, ptr %ub.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.12, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 0, i64 0, i64 0, i64 0) ], !dbg !71
  call void @llvm.directive.region.exit(token %1), !dbg !72
  ret void, !dbg !73
}

define internal i32 @compute_lb.10(ptr %lb) #2 !dbg !74 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !75
  ret i32 %0, !dbg !75
}

define internal i32 @compute_ub.11(ptr %ub) #2 !dbg !77 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !78
  ret i32 %0, !dbg !78
}

define internal i32 @compute_step.12(ptr %step) #2 !dbg !80 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !81
  ret i32 %0, !dbg !81
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z17unsigned_loop_slejjj(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !83 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %lb.addr, align 4, !dbg !84
  store i32 %0, ptr %i, align 4, !dbg !85
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.13, ptr %lb.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.14, ptr %ub.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.15, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 1, i64 0, i64 0, i64 0, i64 0) ], !dbg !86
  call void @llvm.directive.region.exit(token %1), !dbg !87
  ret void, !dbg !88
}

define internal i32 @compute_lb.13(ptr %lb) #2 !dbg !89 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !90
  ret i32 %0, !dbg !90
}

define internal i32 @compute_ub.14(ptr %ub) #2 !dbg !92 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !93
  ret i32 %0, !dbg !93
}

define internal i32 @compute_step.15(ptr %step) #2 !dbg !95 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !96
  ret i32 %0, !dbg !96
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z17unsigned_loop_sgtjjj(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !98 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %ub.addr, align 4, !dbg !99
  store i32 %0, ptr %i, align 4, !dbg !100
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.16, ptr %ub.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.17, ptr %lb.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.18, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 2, i64 0, i64 0, i64 0, i64 0) ], !dbg !101
  call void @llvm.directive.region.exit(token %1), !dbg !102
  ret void, !dbg !103
}

define internal i32 @compute_lb.16(ptr %ub) #2 !dbg !104 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !105
  ret i32 %0, !dbg !105
}

define internal i32 @compute_ub.17(ptr %lb) #2 !dbg !107 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !108
  ret i32 %0, !dbg !108
}

define internal i32 @compute_step.18(ptr %step) #2 !dbg !110 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !111
  %sub = sub i32 0, %0, !dbg !111
  ret i32 %sub, !dbg !111
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z17unsigned_loop_sgejjj(i32 noundef %lb, i32 noundef %ub, i32 noundef %step) #0 !dbg !113 {
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %lb, ptr %lb.addr, align 4
  store i32 %ub, ptr %ub.addr, align 4
  store i32 %step, ptr %step.addr, align 4
  %0 = load i32, ptr %ub.addr, align 4, !dbg !114
  store i32 %0, ptr %i, align 4, !dbg !115
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %ub.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %lb.addr, i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr %step.addr, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.19, ptr %ub.addr), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.20, ptr %lb.addr), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.21, ptr %step.addr), "QUAL.OSS.LOOP.TYPE"(i64 3, i64 0, i64 0, i64 0, i64 0) ], !dbg !116
  call void @llvm.directive.region.exit(token %1), !dbg !117
  ret void, !dbg !118
}

define internal i32 @compute_lb.19(ptr %ub) #2 !dbg !119 {
entry:
  %ub.addr = alloca ptr, align 8
  store ptr %ub, ptr %ub.addr, align 8
  %0 = load i32, ptr %ub, align 4, !dbg !120
  ret i32 %0, !dbg !120
}

define internal i32 @compute_ub.20(ptr %lb) #2 !dbg !122 {
entry:
  %lb.addr = alloca ptr, align 8
  store ptr %lb, ptr %lb.addr, align 8
  %0 = load i32, ptr %lb, align 4, !dbg !123
  ret i32 %0, !dbg !123
}

define internal i32 @compute_step.21(ptr %step) #2 !dbg !125 {
entry:
  %step.addr = alloca ptr, align 8
  store ptr %step, ptr %step.addr, align 8
  %0 = load i32, ptr %step, align 4, !dbg !126
  %sub = sub i32 0, %0, !dbg !126
  ret i32 %sub, !dbg !126
}

; Function Attrs: mustprogress noinline nounwind optnone
define dso_local void @_Z14constants_loopv() #0 !dbg !128 {
entry:
  %i = alloca i32, align 4
  store i32 0, ptr %i, align 4, !dbg !129
  %0 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(ptr %i, i32 undef), "QUAL.OSS.LOOP.IND.VAR"(ptr %i), "QUAL.OSS.LOOP.LOWER.BOUND"(ptr @compute_lb.22), "QUAL.OSS.LOOP.UPPER.BOUND"(ptr @compute_ub.23), "QUAL.OSS.LOOP.STEP"(ptr @compute_step.24), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 1, i64 1, i64 1, i64 1) ], !dbg !130
  call void @llvm.directive.region.exit(token %0), !dbg !131
  ret void, !dbg !132
}

define internal i32 @compute_lb.22() #2 !dbg !133 {
entry:
  ret i32 0, !dbg !134
}

define internal i32 @compute_ub.23() #2 !dbg !136 {
entry:
  ret i32 10, !dbg !137
}

define internal i32 @compute_step.24() #2 !dbg !139 {
entry:
  ret i32 1, !dbg !140
}

attributes #0 = { mustprogress noinline nounwind optnone "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
attributes #1 = { nounwind }
attributes #2 = { "min-legal-vector-width"="0" }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2, !3}
!llvm.ident = !{!4}

!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "<stdin>", directory: "")
!2 = !{i32 2, !"Debug Info Version", i32 3}
!3 = !{i32 1, !"wchar_size", i32 4}
!4 = !{!""}
!5 = distinct !DISubprogram(name: "signed_loop_slt", scope: !6, file: !6, line: 1, type: !7, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!6 = !DIFile(filename: "task_for_cond_and_register_check.ll", directory: "")
!7 = !DISubroutineType(types: !8)
!8 = !{}
!9 = !DILocation(line: 3, column: 18, scope: !5)
!10 = !DILocation(line: 3, column: 14, scope: !5)
!11 = !DILocation(line: 3, column: 10, scope: !5)
!12 = !DILocation(line: 3, column: 42, scope: !5)
!13 = !DILocation(line: 4, column: 1, scope: !5)
!14 = distinct !DISubprogram(linkageName: "compute_lb", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!15 = !DILocation(line: 3, column: 18, scope: !16)
!16 = !DILexicalBlockFile(scope: !14, file: !6, discriminator: 0)
!17 = distinct !DISubprogram(linkageName: "compute_ub", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!18 = !DILocation(line: 3, column: 26, scope: !19)
!19 = !DILexicalBlockFile(scope: !17, file: !6, discriminator: 0)
!20 = distinct !DISubprogram(linkageName: "compute_step", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!21 = !DILocation(line: 3, column: 35, scope: !22)
!22 = !DILexicalBlockFile(scope: !20, file: !6, discriminator: 0)
!23 = distinct !DISubprogram(name: "signed_loop_sle", scope: !6, file: !6, line: 5, type: !7, scopeLine: 5, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!24 = !DILocation(line: 7, column: 18, scope: !23)
!25 = !DILocation(line: 7, column: 14, scope: !23)
!26 = !DILocation(line: 7, column: 10, scope: !23)
!27 = !DILocation(line: 7, column: 43, scope: !23)
!28 = !DILocation(line: 8, column: 1, scope: !23)
!29 = distinct !DISubprogram(linkageName: "compute_lb.1", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!30 = !DILocation(line: 7, column: 18, scope: !31)
!31 = !DILexicalBlockFile(scope: !29, file: !6, discriminator: 0)
!32 = distinct !DISubprogram(linkageName: "compute_ub.2", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!33 = !DILocation(line: 7, column: 27, scope: !34)
!34 = !DILexicalBlockFile(scope: !32, file: !6, discriminator: 0)
!35 = distinct !DISubprogram(linkageName: "compute_step.3", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!36 = !DILocation(line: 7, column: 36, scope: !37)
!37 = !DILexicalBlockFile(scope: !35, file: !6, discriminator: 0)
!38 = distinct !DISubprogram(name: "signed_loop_sgt", scope: !6, file: !6, line: 9, type: !7, scopeLine: 9, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!39 = !DILocation(line: 11, column: 18, scope: !38)
!40 = !DILocation(line: 11, column: 14, scope: !38)
!41 = !DILocation(line: 11, column: 10, scope: !38)
!42 = !DILocation(line: 11, column: 42, scope: !38)
!43 = !DILocation(line: 12, column: 1, scope: !38)
!44 = distinct !DISubprogram(linkageName: "compute_lb.4", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!45 = !DILocation(line: 11, column: 18, scope: !46)
!46 = !DILexicalBlockFile(scope: !44, file: !6, discriminator: 0)
!47 = distinct !DISubprogram(linkageName: "compute_ub.5", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!48 = !DILocation(line: 11, column: 26, scope: !49)
!49 = !DILexicalBlockFile(scope: !47, file: !6, discriminator: 0)
!50 = distinct !DISubprogram(linkageName: "compute_step.6", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!51 = !DILocation(line: 11, column: 35, scope: !52)
!52 = !DILexicalBlockFile(scope: !50, file: !6, discriminator: 0)
!53 = distinct !DISubprogram(name: "signed_loop_sge", scope: !6, file: !6, line: 13, type: !7, scopeLine: 13, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!54 = !DILocation(line: 15, column: 18, scope: !53)
!55 = !DILocation(line: 15, column: 14, scope: !53)
!56 = !DILocation(line: 15, column: 10, scope: !53)
!57 = !DILocation(line: 15, column: 43, scope: !53)
!58 = !DILocation(line: 16, column: 1, scope: !53)
!59 = distinct !DISubprogram(linkageName: "compute_lb.7", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!60 = !DILocation(line: 15, column: 18, scope: !61)
!61 = !DILexicalBlockFile(scope: !59, file: !6, discriminator: 0)
!62 = distinct !DISubprogram(linkageName: "compute_ub.8", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!63 = !DILocation(line: 15, column: 27, scope: !64)
!64 = !DILexicalBlockFile(scope: !62, file: !6, discriminator: 0)
!65 = distinct !DISubprogram(linkageName: "compute_step.9", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!66 = !DILocation(line: 15, column: 36, scope: !67)
!67 = !DILexicalBlockFile(scope: !65, file: !6, discriminator: 0)
!68 = distinct !DISubprogram(name: "unsigned_loop_slt", scope: !6, file: !6, line: 17, type: !7, scopeLine: 17, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!69 = !DILocation(line: 19, column: 23, scope: !68)
!70 = !DILocation(line: 19, column: 19, scope: !68)
!71 = !DILocation(line: 19, column: 10, scope: !68)
!72 = !DILocation(line: 19, column: 47, scope: !68)
!73 = !DILocation(line: 20, column: 1, scope: !68)
!74 = distinct !DISubprogram(linkageName: "compute_lb.10", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!75 = !DILocation(line: 19, column: 23, scope: !76)
!76 = !DILexicalBlockFile(scope: !74, file: !6, discriminator: 0)
!77 = distinct !DISubprogram(linkageName: "compute_ub.11", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!78 = !DILocation(line: 19, column: 31, scope: !79)
!79 = !DILexicalBlockFile(scope: !77, file: !6, discriminator: 0)
!80 = distinct !DISubprogram(linkageName: "compute_step.12", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!81 = !DILocation(line: 19, column: 40, scope: !82)
!82 = !DILexicalBlockFile(scope: !80, file: !6, discriminator: 0)
!83 = distinct !DISubprogram(name: "unsigned_loop_sle", scope: !6, file: !6, line: 21, type: !7, scopeLine: 21, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!84 = !DILocation(line: 23, column: 23, scope: !83)
!85 = !DILocation(line: 23, column: 19, scope: !83)
!86 = !DILocation(line: 23, column: 10, scope: !83)
!87 = !DILocation(line: 23, column: 48, scope: !83)
!88 = !DILocation(line: 24, column: 1, scope: !83)
!89 = distinct !DISubprogram(linkageName: "compute_lb.13", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!90 = !DILocation(line: 23, column: 23, scope: !91)
!91 = !DILexicalBlockFile(scope: !89, file: !6, discriminator: 0)
!92 = distinct !DISubprogram(linkageName: "compute_ub.14", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!93 = !DILocation(line: 23, column: 32, scope: !94)
!94 = !DILexicalBlockFile(scope: !92, file: !6, discriminator: 0)
!95 = distinct !DISubprogram(linkageName: "compute_step.15", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!96 = !DILocation(line: 23, column: 41, scope: !97)
!97 = !DILexicalBlockFile(scope: !95, file: !6, discriminator: 0)
!98 = distinct !DISubprogram(name: "unsigned_loop_sgt", scope: !6, file: !6, line: 25, type: !7, scopeLine: 25, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!99 = !DILocation(line: 27, column: 23, scope: !98)
!100 = !DILocation(line: 27, column: 19, scope: !98)
!101 = !DILocation(line: 27, column: 10, scope: !98)
!102 = !DILocation(line: 27, column: 47, scope: !98)
!103 = !DILocation(line: 28, column: 1, scope: !98)
!104 = distinct !DISubprogram(linkageName: "compute_lb.16", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!105 = !DILocation(line: 27, column: 23, scope: !106)
!106 = !DILexicalBlockFile(scope: !104, file: !6, discriminator: 0)
!107 = distinct !DISubprogram(linkageName: "compute_ub.17", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!108 = !DILocation(line: 27, column: 31, scope: !109)
!109 = !DILexicalBlockFile(scope: !107, file: !6, discriminator: 0)
!110 = distinct !DISubprogram(linkageName: "compute_step.18", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!111 = !DILocation(line: 27, column: 40, scope: !112)
!112 = !DILexicalBlockFile(scope: !110, file: !6, discriminator: 0)
!113 = distinct !DISubprogram(name: "unsigned_loop_sge", scope: !6, file: !6, line: 29, type: !7, scopeLine: 29, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!114 = !DILocation(line: 31, column: 23, scope: !113)
!115 = !DILocation(line: 31, column: 19, scope: !113)
!116 = !DILocation(line: 31, column: 10, scope: !113)
!117 = !DILocation(line: 31, column: 48, scope: !113)
!118 = !DILocation(line: 32, column: 1, scope: !113)
!119 = distinct !DISubprogram(linkageName: "compute_lb.19", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!120 = !DILocation(line: 31, column: 23, scope: !121)
!121 = !DILexicalBlockFile(scope: !119, file: !6, discriminator: 0)
!122 = distinct !DISubprogram(linkageName: "compute_ub.20", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!123 = !DILocation(line: 31, column: 32, scope: !124)
!124 = !DILexicalBlockFile(scope: !122, file: !6, discriminator: 0)
!125 = distinct !DISubprogram(linkageName: "compute_step.21", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!126 = !DILocation(line: 31, column: 41, scope: !127)
!127 = !DILexicalBlockFile(scope: !125, file: !6, discriminator: 0)
!128 = distinct !DISubprogram(name: "constants_loop", scope: !6, file: !6, line: 33, type: !7, scopeLine: 33, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !8)
!129 = !DILocation(line: 35, column: 14, scope: !128)
!130 = !DILocation(line: 35, column: 10, scope: !128)
!131 = !DILocation(line: 35, column: 38, scope: !128)
!132 = !DILocation(line: 36, column: 1, scope: !128)
!133 = distinct !DISubprogram(linkageName: "compute_lb.22", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!134 = !DILocation(line: 35, column: 18, scope: !135)
!135 = !DILexicalBlockFile(scope: !133, file: !6, discriminator: 0)
!136 = distinct !DISubprogram(linkageName: "compute_ub.23", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!137 = !DILocation(line: 35, column: 25, scope: !138)
!138 = !DILexicalBlockFile(scope: !136, file: !6, discriminator: 0)
!139 = distinct !DISubprogram(linkageName: "compute_step.24", scope: !1, file: !1, type: !7, flags: DIFlagArtificial, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0, retainedNodes: !8)
!140 = !DILocation(line: 35, column: 34, scope: !141)
!141 = !DILexicalBlockFile(scope: !139, file: !6, discriminator: 0)
; CHECK-LABEL: define {{[^@]+}}@_Z15signed_loop_sltiii
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0:[0-9]+]] !dbg [[DBG5:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB_ADDR]], align 4, !dbg [[DBG9:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG10:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG11:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG11]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG11]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG11]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb(ptr [[LB_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub(ptr [[UB_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step(ptr [[STEP_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[TMP7]], 1, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP9:%.*]] = sdiv i32 [[TMP8]], [[TMP6]], !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP9]], 1, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP11:%.*]] = sext i32 [[TMP10]] to i64, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP12:%.*]] = mul i64 1, [[TMP11]], !dbg [[DBG11]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z15signed_loop_sltiii, ptr @task_invocation_info__Z15signed_loop_sltiii, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP12]], i64 0, i64 0), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG11]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP13]], i64 16, !dbg [[DBG11]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII:%.*]], ptr [[TMP13]], i32 0, i32 1, !dbg [[DBG11]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG11]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII]], ptr [[TMP13]], i32 0, i32 2, !dbg [[DBG11]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG11]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII]], ptr [[TMP13]], i32 0, i32 3, !dbg [[DBG11]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG11]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP14]]), !dbg [[DBG11]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG11]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG12:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_lb(ptr [[LB_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_ub(ptr [[UB_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP17:%.*]] = call i32 @compute_step(ptr [[STEP_ADDR]]), !dbg [[DBG11]]
; CHECK-NEXT:    store i32 [[TMP15]], ptr [[I]], align 4, !dbg [[DBG11]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG11]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP19:%.*]] = icmp slt i32 [[TMP18]], [[TMP16]], !dbg [[DBG11]]
; CHECK-NEXT:    br i1 [[TMP19]], label [[TMP20:%.*]], label [[FOR_END:%.*]], !dbg [[DBG11]]
; CHECK:       20:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG11]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG12]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG11]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP22:%.*]] = add i32 [[TMP21]], [[TMP17]], !dbg [[DBG11]]
; CHECK-NEXT:    store i32 [[TMP22]], ptr [[I]], align 4, !dbg [[DBG11]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG11]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP23:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG11]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ne i32 [[TMP23]], 0, !dbg [[DBG11]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG11]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG11]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2:[0-9]+]] !dbg [[DBG13:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG14:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG14]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG16:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG17:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG17]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG19:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG20:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG20]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z15signed_loop_sleiii
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG22:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB_ADDR]], align 4, !dbg [[DBG23:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG24:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG25:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG25]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG25]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG25]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.1(ptr [[LB_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.2(ptr [[UB_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.3(ptr [[STEP_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP6]], !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]], !dbg [[DBG25]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z15signed_loop_sleiii, ptr @task_invocation_info__Z15signed_loop_sleiii, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP11]], i64 0, i64 0), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG25]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP12]], i64 16, !dbg [[DBG25]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII:%.*]], ptr [[TMP12]], i32 0, i32 1, !dbg [[DBG25]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG25]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII]], ptr [[TMP12]], i32 0, i32 2, !dbg [[DBG25]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG25]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII]], ptr [[TMP12]], i32 0, i32 3, !dbg [[DBG25]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG25]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP13]]), !dbg [[DBG25]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG25]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG26:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP14:%.*]] = call i32 @compute_lb.1(ptr [[LB_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_ub.2(ptr [[UB_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_step.3(ptr [[STEP_ADDR]]), !dbg [[DBG25]]
; CHECK-NEXT:    store i32 [[TMP14]], ptr [[I]], align 4, !dbg [[DBG25]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG25]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp sle i32 [[TMP17]], [[TMP15]], !dbg [[DBG25]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[FOR_END:%.*]], !dbg [[DBG25]]
; CHECK:       19:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG25]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG26]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG25]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP21:%.*]] = add i32 [[TMP20]], [[TMP16]], !dbg [[DBG25]]
; CHECK-NEXT:    store i32 [[TMP21]], ptr [[I]], align 4, !dbg [[DBG25]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG25]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG25]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ne i32 [[TMP22]], 0, !dbg [[DBG25]]
; CHECK-NEXT:    br i1 [[TMP23]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG25]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG25]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.1
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG27:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG28:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG28]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.2
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG30:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG31:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG31]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.3
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG33:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG34:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG34]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z15signed_loop_sgtiii
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG36:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB_ADDR]], align 4, !dbg [[DBG37:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG38:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG39:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG39]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG39]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG39]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.4(ptr [[UB_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.5(ptr [[LB_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.6(ptr [[STEP_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP9:%.*]] = sdiv i32 [[TMP8]], [[TMP6]], !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP9]], 1, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP11:%.*]] = sext i32 [[TMP10]] to i64, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP12:%.*]] = mul i64 1, [[TMP11]], !dbg [[DBG39]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z15signed_loop_sgtiii, ptr @task_invocation_info__Z15signed_loop_sgtiii, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP12]], i64 0, i64 0), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG39]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP13]], i64 16, !dbg [[DBG39]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII:%.*]], ptr [[TMP13]], i32 0, i32 1, !dbg [[DBG39]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG39]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII]], ptr [[TMP13]], i32 0, i32 2, !dbg [[DBG39]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG39]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII]], ptr [[TMP13]], i32 0, i32 3, !dbg [[DBG39]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG39]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP14]]), !dbg [[DBG39]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG39]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG40:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_lb.4(ptr [[UB_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_ub.5(ptr [[LB_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP17:%.*]] = call i32 @compute_step.6(ptr [[STEP_ADDR]]), !dbg [[DBG39]]
; CHECK-NEXT:    store i32 [[TMP15]], ptr [[I]], align 4, !dbg [[DBG39]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG39]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP19:%.*]] = icmp sgt i32 [[TMP18]], [[TMP16]], !dbg [[DBG39]]
; CHECK-NEXT:    br i1 [[TMP19]], label [[TMP20:%.*]], label [[FOR_END:%.*]], !dbg [[DBG39]]
; CHECK:       20:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG39]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG40]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG39]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP22:%.*]] = add i32 [[TMP21]], [[TMP17]], !dbg [[DBG39]]
; CHECK-NEXT:    store i32 [[TMP22]], ptr [[I]], align 4, !dbg [[DBG39]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG39]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP23:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG39]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ne i32 [[TMP23]], 0, !dbg [[DBG39]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG39]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG39]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.4
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG41:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG42:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG42]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.5
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG44:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG45:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG45]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.6
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG47:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG48:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 0, [[TMP0]], !dbg [[DBG48]]
; CHECK-NEXT:    ret i32 [[SUB]], !dbg [[DBG48]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z15signed_loop_sgeiii
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG50:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB_ADDR]], align 4, !dbg [[DBG51:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG52:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG53:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG53]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG53]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG53]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.7(ptr [[UB_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.8(ptr [[LB_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.9(ptr [[STEP_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP6]], !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]], !dbg [[DBG53]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z15signed_loop_sgeiii, ptr @task_invocation_info__Z15signed_loop_sgeiii, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP11]], i64 0, i64 0), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG53]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP12]], i64 16, !dbg [[DBG53]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII:%.*]], ptr [[TMP12]], i32 0, i32 1, !dbg [[DBG53]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG53]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII]], ptr [[TMP12]], i32 0, i32 2, !dbg [[DBG53]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG53]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII]], ptr [[TMP12]], i32 0, i32 3, !dbg [[DBG53]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG53]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP13]]), !dbg [[DBG53]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG53]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG54:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP14:%.*]] = call i32 @compute_lb.7(ptr [[UB_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_ub.8(ptr [[LB_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_step.9(ptr [[STEP_ADDR]]), !dbg [[DBG53]]
; CHECK-NEXT:    store i32 [[TMP14]], ptr [[I]], align 4, !dbg [[DBG53]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG53]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp sge i32 [[TMP17]], [[TMP15]], !dbg [[DBG53]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[FOR_END:%.*]], !dbg [[DBG53]]
; CHECK:       19:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG53]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG54]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG53]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP21:%.*]] = add i32 [[TMP20]], [[TMP16]], !dbg [[DBG53]]
; CHECK-NEXT:    store i32 [[TMP21]], ptr [[I]], align 4, !dbg [[DBG53]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG53]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG53]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ne i32 [[TMP22]], 0, !dbg [[DBG53]]
; CHECK-NEXT:    br i1 [[TMP23]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG53]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG53]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.7
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG55:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG56:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG56]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.8
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG58:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG59:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG59]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.9
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG61:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG62:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 0, [[TMP0]], !dbg [[DBG62]]
; CHECK-NEXT:    ret i32 [[SUB]], !dbg [[DBG62]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z17unsigned_loop_sltjjj
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG64:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB_ADDR]], align 4, !dbg [[DBG65:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG66:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG67:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG67]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG67]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG67]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.10(ptr [[LB_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.11(ptr [[UB_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.12(ptr [[STEP_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[TMP7]], 1, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP9:%.*]] = udiv i32 [[TMP8]], [[TMP6]], !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP9]], 1, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP11:%.*]] = zext i32 [[TMP10]] to i64, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP12:%.*]] = mul i64 1, [[TMP11]], !dbg [[DBG67]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z17unsigned_loop_sltjjj, ptr @task_invocation_info__Z17unsigned_loop_sltjjj, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP12]], i64 0, i64 0), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG67]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP13]], i64 16, !dbg [[DBG67]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ:%.*]], ptr [[TMP13]], i32 0, i32 1, !dbg [[DBG67]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG67]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ]], ptr [[TMP13]], i32 0, i32 2, !dbg [[DBG67]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG67]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ]], ptr [[TMP13]], i32 0, i32 3, !dbg [[DBG67]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG67]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP14]]), !dbg [[DBG67]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG67]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG68:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_lb.10(ptr [[LB_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_ub.11(ptr [[UB_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP17:%.*]] = call i32 @compute_step.12(ptr [[STEP_ADDR]]), !dbg [[DBG67]]
; CHECK-NEXT:    store i32 [[TMP15]], ptr [[I]], align 4, !dbg [[DBG67]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG67]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP19:%.*]] = icmp ult i32 [[TMP18]], [[TMP16]], !dbg [[DBG67]]
; CHECK-NEXT:    br i1 [[TMP19]], label [[TMP20:%.*]], label [[FOR_END:%.*]], !dbg [[DBG67]]
; CHECK:       20:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG67]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG68]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG67]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP22:%.*]] = add i32 [[TMP21]], [[TMP17]], !dbg [[DBG67]]
; CHECK-NEXT:    store i32 [[TMP22]], ptr [[I]], align 4, !dbg [[DBG67]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG67]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP23:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG67]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ne i32 [[TMP23]], 0, !dbg [[DBG67]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG67]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG67]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.10
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG69:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG70:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG70]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.11
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG72:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG73:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG73]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.12
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG75:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG76:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG76]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z17unsigned_loop_slejjj
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG78:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB_ADDR]], align 4, !dbg [[DBG79:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG80:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG81:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG81]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG81]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG81]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.13(ptr [[LB_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.14(ptr [[UB_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.15(ptr [[STEP_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[TMP7]], [[TMP6]], !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]], !dbg [[DBG81]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z17unsigned_loop_slejjj, ptr @task_invocation_info__Z17unsigned_loop_slejjj, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP11]], i64 0, i64 0), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG81]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP12]], i64 16, !dbg [[DBG81]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ:%.*]], ptr [[TMP12]], i32 0, i32 1, !dbg [[DBG81]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG81]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ]], ptr [[TMP12]], i32 0, i32 2, !dbg [[DBG81]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG81]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ]], ptr [[TMP12]], i32 0, i32 3, !dbg [[DBG81]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG81]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP13]]), !dbg [[DBG81]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG81]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG82:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP14:%.*]] = call i32 @compute_lb.13(ptr [[LB_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_ub.14(ptr [[UB_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_step.15(ptr [[STEP_ADDR]]), !dbg [[DBG81]]
; CHECK-NEXT:    store i32 [[TMP14]], ptr [[I]], align 4, !dbg [[DBG81]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG81]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ule i32 [[TMP17]], [[TMP15]], !dbg [[DBG81]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[FOR_END:%.*]], !dbg [[DBG81]]
; CHECK:       19:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG81]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG82]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG81]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP21:%.*]] = add i32 [[TMP20]], [[TMP16]], !dbg [[DBG81]]
; CHECK-NEXT:    store i32 [[TMP21]], ptr [[I]], align 4, !dbg [[DBG81]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG81]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG81]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ne i32 [[TMP22]], 0, !dbg [[DBG81]]
; CHECK-NEXT:    br i1 [[TMP23]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG81]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG81]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.13
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG83:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG84:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG84]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.14
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG86:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG87:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG87]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.15
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG89:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG90:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG90]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z17unsigned_loop_sgtjjj
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG92:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB_ADDR]], align 4, !dbg [[DBG93:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG94:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG95:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG95]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG95]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG95]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.16(ptr [[UB_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.17(ptr [[LB_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.18(ptr [[STEP_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP9:%.*]] = udiv i32 [[TMP8]], [[TMP6]], !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP9]], 1, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP11:%.*]] = zext i32 [[TMP10]] to i64, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP12:%.*]] = mul i64 1, [[TMP11]], !dbg [[DBG95]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z17unsigned_loop_sgtjjj, ptr @task_invocation_info__Z17unsigned_loop_sgtjjj, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP12]], i64 0, i64 0), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG95]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP13]], i64 16, !dbg [[DBG95]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ:%.*]], ptr [[TMP13]], i32 0, i32 1, !dbg [[DBG95]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG95]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ]], ptr [[TMP13]], i32 0, i32 2, !dbg [[DBG95]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG95]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ]], ptr [[TMP13]], i32 0, i32 3, !dbg [[DBG95]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG95]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP14]]), !dbg [[DBG95]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG95]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG96:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_lb.16(ptr [[UB_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_ub.17(ptr [[LB_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP17:%.*]] = call i32 @compute_step.18(ptr [[STEP_ADDR]]), !dbg [[DBG95]]
; CHECK-NEXT:    store i32 [[TMP15]], ptr [[I]], align 4, !dbg [[DBG95]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG95]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP19:%.*]] = icmp ugt i32 [[TMP18]], [[TMP16]], !dbg [[DBG95]]
; CHECK-NEXT:    br i1 [[TMP19]], label [[TMP20:%.*]], label [[FOR_END:%.*]], !dbg [[DBG95]]
; CHECK:       20:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG95]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG96]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG95]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP22:%.*]] = add i32 [[TMP21]], [[TMP17]], !dbg [[DBG95]]
; CHECK-NEXT:    store i32 [[TMP22]], ptr [[I]], align 4, !dbg [[DBG95]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG95]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP23:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG95]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ne i32 [[TMP23]], 0, !dbg [[DBG95]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG95]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG95]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.16
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG97:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG98:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG98]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.17
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG100:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG101:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG101]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.18
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG103:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG104:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 0, [[TMP0]], !dbg [[DBG104]]
; CHECK-NEXT:    ret i32 [[SUB]], !dbg [[DBG104]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z17unsigned_loop_sgejjj
; CHECK-SAME: (i32 noundef [[LB:%.*]], i32 noundef [[UB:%.*]], i32 noundef [[STEP:%.*]]) #[[ATTR0]] !dbg [[DBG106:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB]], ptr [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB]], ptr [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP]], ptr [[STEP_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB_ADDR]], align 4, !dbg [[DBG107:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4, !dbg [[DBG108:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG109:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca ptr, align 8, !dbg [[DBG109]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG109]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG109]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_lb.19(ptr [[UB_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_ub.20(ptr [[LB_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @compute_step.21(ptr [[STEP_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP5]], [[TMP4]], !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[TMP7]], [[TMP6]], !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]], !dbg [[DBG109]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z17unsigned_loop_sgejjj, ptr @task_invocation_info__Z17unsigned_loop_sgejjj, ptr null, i64 16, ptr [[TMP1]], ptr [[TMP2]], i64 8, i64 [[TMP3]], i64 0, i64 [[TMP11]], i64 0, i64 0), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG109]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP12]], i64 16, !dbg [[DBG109]]
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ:%.*]], ptr [[TMP12]], i32 0, i32 1, !dbg [[DBG109]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_UB_ADDR]], ptr align 4 [[UB_ADDR]], i64 4, i1 false), !dbg [[DBG109]]
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ]], ptr [[TMP12]], i32 0, i32 2, !dbg [[DBG109]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_LB_ADDR]], ptr align 4 [[LB_ADDR]], i64 4, i1 false), !dbg [[DBG109]]
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ]], ptr [[TMP12]], i32 0, i32 3, !dbg [[DBG109]]
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[GEP_STEP_ADDR]], ptr align 4 [[STEP_ADDR]], i64 4, i1 false), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG109]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP13]]), !dbg [[DBG109]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG109]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG110:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP14:%.*]] = call i32 @compute_lb.19(ptr [[UB_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_ub.20(ptr [[LB_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_step.21(ptr [[STEP_ADDR]]), !dbg [[DBG109]]
; CHECK-NEXT:    store i32 [[TMP14]], ptr [[I]], align 4, !dbg [[DBG109]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG109]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp uge i32 [[TMP17]], [[TMP15]], !dbg [[DBG109]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[FOR_END:%.*]], !dbg [[DBG109]]
; CHECK:       19:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG109]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG110]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG109]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP21:%.*]] = add i32 [[TMP20]], [[TMP16]], !dbg [[DBG109]]
; CHECK-NEXT:    store i32 [[TMP21]], ptr [[I]], align 4, !dbg [[DBG109]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG109]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG109]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ne i32 [[TMP22]], 0, !dbg [[DBG109]]
; CHECK-NEXT:    br i1 [[TMP23]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG109]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG109]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.19
; CHECK-SAME: (ptr [[UB:%.*]]) #[[ATTR2]] !dbg [[DBG111:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[UB]], ptr [[UB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[UB]], align 4, !dbg [[DBG112:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG112]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.20
; CHECK-SAME: (ptr [[LB:%.*]]) #[[ATTR2]] !dbg [[DBG114:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[LB]], ptr [[LB_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[LB]], align 4, !dbg [[DBG115:![0-9]+]]
; CHECK-NEXT:    ret i32 [[TMP0]], !dbg [[DBG115]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.21
; CHECK-SAME: (ptr [[STEP:%.*]]) #[[ATTR2]] !dbg [[DBG117:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[STEP]], ptr [[STEP_ADDR]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[STEP]], align 4, !dbg [[DBG118:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 0, [[TMP0]], !dbg [[DBG118]]
; CHECK-NEXT:    ret i32 [[SUB]], !dbg [[DBG118]]
;
;
; CHECK-LABEL: define {{[^@]+}}@_Z14constants_loopv
; CHECK-SAME: () #[[ATTR0]] !dbg [[DBG120:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 0, ptr [[I]], align 4, !dbg [[DBG121:![0-9]+]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca ptr, align 8, !dbg [[DBG122:![0-9]+]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca ptr, align 8, !dbg [[DBG122]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, !dbg [[DBG122]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg [[DBG122]]
; CHECK:       codeRepl:
; CHECK-NEXT:    store i64 0, ptr [[NUM_DEPS]], align 8, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[NUM_DEPS]], align 8, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.22(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.23(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.24(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP4]], [[TMP3]], !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP6]], 1, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i64 1, [[TMP10]], !dbg [[DBG122]]
; CHECK-NEXT:    call void @nanos6_create_loop(ptr @task_info_var__Z14constants_loopv, ptr @task_invocation_info__Z14constants_loopv, ptr null, i64 16, ptr [[TMP0]], ptr [[TMP1]], i64 8, i64 [[TMP2]], i64 0, i64 [[TMP11]], i64 0, i64 0), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG122]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, ptr [[TMP12]], i64 16, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG122]]
; CHECK-NEXT:    call void @nanos6_submit_task(ptr [[TMP13]]), !dbg [[DBG122]]
; CHECK-NEXT:    br label [[FOR_END3:%.*]], !dbg [[DBG122]]
; CHECK:       final.end:
; CHECK-NEXT:    ret void, !dbg [[DBG123:![0-9]+]]
; CHECK:       final.then:
; CHECK-NEXT:    [[TMP14:%.*]] = call i32 @compute_lb.22(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @compute_ub.23(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @compute_step.24(), !dbg [[DBG122]]
; CHECK-NEXT:    store i32 [[TMP14]], ptr [[I]], align 4, !dbg [[DBG122]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], !dbg [[DBG122]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP18:%.*]] = icmp slt i32 [[TMP17]], [[TMP15]], !dbg [[DBG122]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[FOR_END:%.*]], !dbg [[DBG122]]
; CHECK:       19:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG122]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], !dbg [[DBG123]]
; CHECK:       for.end:
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg [[DBG122]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP21:%.*]] = add i32 [[TMP20]], [[TMP16]], !dbg [[DBG122]]
; CHECK-NEXT:    store i32 [[TMP21]], ptr [[I]], align 4, !dbg [[DBG122]]
; CHECK-NEXT:    br label [[FOR_COND]], !dbg [[DBG122]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP22:%.*]] = call i32 @nanos6_in_final(), !dbg [[DBG122]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ne i32 [[TMP22]], 0, !dbg [[DBG122]]
; CHECK-NEXT:    br i1 [[TMP23]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg [[DBG122]]
; CHECK:       for.end3:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg [[DBG122]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_lb.22
; CHECK-SAME: () #[[ATTR2]] !dbg [[DBG124:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i32 0, !dbg [[DBG125:![0-9]+]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_ub.23
; CHECK-SAME: () #[[ATTR2]] !dbg [[DBG127:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i32 10, !dbg [[DBG128:![0-9]+]]
;
;
; CHECK-LABEL: define {{[^@]+}}@compute_step.24
; CHECK-SAME: () #[[ATTR2]] !dbg [[DBG130:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret i32 1, !dbg [[DBG131:![0-9]+]]
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z15signed_loop_sltiii
; CHECK-SAME: (ptr [[I:%.*]], ptr [[LB_ADDR:%.*]], ptr [[UB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG133:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG134:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG134]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG134]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG134]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb(ptr [[LB_ADDR]]), !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub(ptr [[UB_ADDR]]), !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step(ptr [[STEP_ADDR]]), !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP6]], 1, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG134]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG134]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG134]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp slt i32 [[TMP11]], [[UB6]], !dbg [[DBG134]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG134]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP15:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i64 [[TMP15]], 1, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP17:%.*]] = sext i32 [[TMP5]] to i64, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i64 [[TMP16]], [[TMP17]], !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP19:%.*]] = sext i32 [[TMP3]] to i64, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP22]], [[TMP21]], !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP24:%.*]] = trunc i64 [[TMP20]] to i32, !dbg [[DBG134]]
; CHECK-NEXT:    store i32 [[TMP24]], ptr [[I]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG134]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG135:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG134]]
; CHECK-NEXT:    store i32 [[TMP26]], ptr [[LOOP]], align 4, !dbg [[DBG134]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG134]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z15signed_loop_sltiii
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLTIII]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z15signed_loop_sltiii(ptr [[GEP_I]], ptr [[GEP_LB_ADDR]], ptr [[GEP_UB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_constructor_register_task_info() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z15signed_loop_sltiii)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z15signed_loop_sleiii)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z15signed_loop_sgtiii)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z15signed_loop_sgeiii)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z17unsigned_loop_sltjjj)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z17unsigned_loop_slejjj)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z17unsigned_loop_sgtjjj)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z17unsigned_loop_sgejjj)
; CHECK-NEXT:    call void @nanos6_register_task_info(ptr @task_info_var__Z14constants_loopv)
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z15signed_loop_sleiii
; CHECK-SAME: (ptr [[I:%.*]], ptr [[LB_ADDR:%.*]], ptr [[UB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG136:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG137:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG137]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG137]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG137]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.1(ptr [[LB_ADDR]]), !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.2(ptr [[UB_ADDR]]), !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.3(ptr [[STEP_ADDR]]), !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP7:%.*]] = sdiv i32 [[TMP6]], [[TMP5]], !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP9:%.*]] = sext i32 [[TMP8]] to i64, !dbg [[DBG137]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG137]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG137]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp slt i32 [[TMP10]], [[UB6]], !dbg [[DBG137]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG137]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP14:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP15:%.*]] = udiv i64 [[TMP14]], 1, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP16:%.*]] = sext i32 [[TMP5]] to i64, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i64 [[TMP15]], [[TMP16]], !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP18:%.*]] = sext i32 [[TMP3]] to i64, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i64 [[TMP17]], [[TMP18]], !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP20:%.*]] = mul i64 [[TMP15]], 1, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP21:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP22:%.*]] = sub i64 [[TMP21]], [[TMP20]], !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP23:%.*]] = trunc i64 [[TMP19]] to i32, !dbg [[DBG137]]
; CHECK-NEXT:    store i32 [[TMP23]], ptr [[I]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG137]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG138:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    [[TMP25:%.*]] = add i32 [[TMP24]], 1, !dbg [[DBG137]]
; CHECK-NEXT:    store i32 [[TMP25]], ptr [[LOOP]], align 4, !dbg [[DBG137]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG137]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z15signed_loop_sleiii
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SLEIII]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z15signed_loop_sleiii(ptr [[GEP_I]], ptr [[GEP_LB_ADDR]], ptr [[GEP_UB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z15signed_loop_sgtiii
; CHECK-SAME: (ptr [[I:%.*]], ptr [[UB_ADDR:%.*]], ptr [[LB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG139:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG140:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG140]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG140]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG140]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.4(ptr [[UB_ADDR]]), !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.5(ptr [[LB_ADDR]]), !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.6(ptr [[STEP_ADDR]]), !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[TMP6]], 1, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG140]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG140]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG140]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp slt i32 [[TMP11]], [[UB6]], !dbg [[DBG140]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG140]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP15:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i64 [[TMP15]], 1, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP17:%.*]] = sext i32 [[TMP5]] to i64, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i64 [[TMP16]], [[TMP17]], !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP19:%.*]] = sext i32 [[TMP3]] to i64, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP22]], [[TMP21]], !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP24:%.*]] = trunc i64 [[TMP20]] to i32, !dbg [[DBG140]]
; CHECK-NEXT:    store i32 [[TMP24]], ptr [[I]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG140]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG141:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG140]]
; CHECK-NEXT:    store i32 [[TMP26]], ptr [[LOOP]], align 4, !dbg [[DBG140]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG140]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z15signed_loop_sgtiii
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGTIII]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z15signed_loop_sgtiii(ptr [[GEP_I]], ptr [[GEP_UB_ADDR]], ptr [[GEP_LB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z15signed_loop_sgeiii
; CHECK-SAME: (ptr [[I:%.*]], ptr [[UB_ADDR:%.*]], ptr [[LB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG142:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG143:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG143]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG143]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG143]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.7(ptr [[UB_ADDR]]), !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.8(ptr [[LB_ADDR]]), !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.9(ptr [[STEP_ADDR]]), !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP7:%.*]] = sdiv i32 [[TMP6]], [[TMP5]], !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP9:%.*]] = sext i32 [[TMP8]] to i64, !dbg [[DBG143]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG143]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG143]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp slt i32 [[TMP10]], [[UB6]], !dbg [[DBG143]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG143]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP14:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP15:%.*]] = udiv i64 [[TMP14]], 1, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP16:%.*]] = sext i32 [[TMP5]] to i64, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i64 [[TMP15]], [[TMP16]], !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP18:%.*]] = sext i32 [[TMP3]] to i64, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i64 [[TMP17]], [[TMP18]], !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP20:%.*]] = mul i64 [[TMP15]], 1, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP21:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP22:%.*]] = sub i64 [[TMP21]], [[TMP20]], !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP23:%.*]] = trunc i64 [[TMP19]] to i32, !dbg [[DBG143]]
; CHECK-NEXT:    store i32 [[TMP23]], ptr [[I]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG143]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG144:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    [[TMP25:%.*]] = add i32 [[TMP24]], 1, !dbg [[DBG143]]
; CHECK-NEXT:    store i32 [[TMP25]], ptr [[LOOP]], align 4, !dbg [[DBG143]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG143]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z15signed_loop_sgeiii
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z15SIGNED_LOOP_SGEIII]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z15signed_loop_sgeiii(ptr [[GEP_I]], ptr [[GEP_UB_ADDR]], ptr [[GEP_LB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z17unsigned_loop_sltjjj
; CHECK-SAME: (ptr [[I:%.*]], ptr [[LB_ADDR:%.*]], ptr [[UB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG145:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG146:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG146]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG146]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG146]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.10(ptr [[LB_ADDR]]), !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.11(ptr [[UB_ADDR]]), !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.12(ptr [[STEP_ADDR]]), !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP6]], 1, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64, !dbg [[DBG146]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG146]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG146]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ult i32 [[TMP11]], [[UB6]], !dbg [[DBG146]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG146]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP15:%.*]] = zext i32 [[TMP14]] to i64, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i64 [[TMP15]], 1, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP17:%.*]] = zext i32 [[TMP5]] to i64, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i64 [[TMP16]], [[TMP17]], !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP3]] to i64, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP22:%.*]] = zext i32 [[TMP14]] to i64, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP22]], [[TMP21]], !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP24:%.*]] = trunc i64 [[TMP20]] to i32, !dbg [[DBG146]]
; CHECK-NEXT:    store i32 [[TMP24]], ptr [[I]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG146]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG147:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG146]]
; CHECK-NEXT:    store i32 [[TMP26]], ptr [[LOOP]], align 4, !dbg [[DBG146]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG146]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z17unsigned_loop_sltjjj
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z17unsigned_loop_sltjjj(ptr [[GEP_I]], ptr [[GEP_LB_ADDR]], ptr [[GEP_UB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z17unsigned_loop_slejjj
; CHECK-SAME: (ptr [[I:%.*]], ptr [[LB_ADDR:%.*]], ptr [[UB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG148:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG149:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG149]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG149]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG149]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.13(ptr [[LB_ADDR]]), !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.14(ptr [[UB_ADDR]]), !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.15(ptr [[STEP_ADDR]]), !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv i32 [[TMP6]], [[TMP5]], !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64, !dbg [[DBG149]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG149]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG149]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ult i32 [[TMP10]], [[UB6]], !dbg [[DBG149]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG149]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP14:%.*]] = zext i32 [[TMP13]] to i64, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP15:%.*]] = udiv i64 [[TMP14]], 1, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP16:%.*]] = zext i32 [[TMP5]] to i64, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i64 [[TMP15]], [[TMP16]], !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP18:%.*]] = zext i32 [[TMP3]] to i64, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i64 [[TMP17]], [[TMP18]], !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP20:%.*]] = mul i64 [[TMP15]], 1, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP21:%.*]] = zext i32 [[TMP13]] to i64, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP22:%.*]] = sub i64 [[TMP21]], [[TMP20]], !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP23:%.*]] = trunc i64 [[TMP19]] to i32, !dbg [[DBG149]]
; CHECK-NEXT:    store i32 [[TMP23]], ptr [[I]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG149]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG150:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    [[TMP25:%.*]] = add i32 [[TMP24]], 1, !dbg [[DBG149]]
; CHECK-NEXT:    store i32 [[TMP25]], ptr [[LOOP]], align 4, !dbg [[DBG149]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG149]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z17unsigned_loop_slejjj
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SLEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z17unsigned_loop_slejjj(ptr [[GEP_I]], ptr [[GEP_LB_ADDR]], ptr [[GEP_UB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z17unsigned_loop_sgtjjj
; CHECK-SAME: (ptr [[I:%.*]], ptr [[UB_ADDR:%.*]], ptr [[LB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG151:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG152:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG152]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG152]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG152]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.16(ptr [[UB_ADDR]]), !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.17(ptr [[LB_ADDR]]), !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.18(ptr [[STEP_ADDR]]), !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[TMP6]], 1, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64, !dbg [[DBG152]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG152]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG152]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ult i32 [[TMP11]], [[UB6]], !dbg [[DBG152]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG152]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP15:%.*]] = zext i32 [[TMP14]] to i64, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i64 [[TMP15]], 1, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP17:%.*]] = zext i32 [[TMP5]] to i64, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i64 [[TMP16]], [[TMP17]], !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP3]] to i64, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP22:%.*]] = zext i32 [[TMP14]] to i64, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP22]], [[TMP21]], !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP24:%.*]] = trunc i64 [[TMP20]] to i32, !dbg [[DBG152]]
; CHECK-NEXT:    store i32 [[TMP24]], ptr [[I]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG152]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG153:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG152]]
; CHECK-NEXT:    store i32 [[TMP26]], ptr [[LOOP]], align 4, !dbg [[DBG152]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG152]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z17unsigned_loop_sgtjjj
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGTJJJ]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z17unsigned_loop_sgtjjj(ptr [[GEP_I]], ptr [[GEP_UB_ADDR]], ptr [[GEP_LB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z17unsigned_loop_sgejjj
; CHECK-SAME: (ptr [[I:%.*]], ptr [[UB_ADDR:%.*]], ptr [[LB_ADDR:%.*]], ptr [[STEP_ADDR:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG154:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG155:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG155]]
; CHECK-NEXT:    [[LB5:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG155]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG155]]
; CHECK-NEXT:    [[UB6:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.19(ptr [[UB_ADDR]]), !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.20(ptr [[LB_ADDR]]), !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.21(ptr [[STEP_ADDR]]), !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB6]], [[LB5]], !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv i32 [[TMP6]], [[TMP5]], !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 1, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64, !dbg [[DBG155]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG155]]
; CHECK-NEXT:    store i32 [[LB5]], ptr [[LOOP]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG155]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ult i32 [[TMP10]], [[UB6]], !dbg [[DBG155]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG155]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP14:%.*]] = zext i32 [[TMP13]] to i64, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP15:%.*]] = udiv i64 [[TMP14]], 1, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP16:%.*]] = zext i32 [[TMP5]] to i64, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i64 [[TMP15]], [[TMP16]], !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP18:%.*]] = zext i32 [[TMP3]] to i64, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i64 [[TMP17]], [[TMP18]], !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP20:%.*]] = mul i64 [[TMP15]], 1, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP21:%.*]] = zext i32 [[TMP13]] to i64, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP22:%.*]] = sub i64 [[TMP21]], [[TMP20]], !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP23:%.*]] = trunc i64 [[TMP19]] to i32, !dbg [[DBG155]]
; CHECK-NEXT:    store i32 [[TMP23]], ptr [[I]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG155]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG156:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP24:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    [[TMP25:%.*]] = add i32 [[TMP24]], 1, !dbg [[DBG155]]
; CHECK-NEXT:    store i32 [[TMP25]], ptr [[LOOP]], align 4, !dbg [[DBG155]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG155]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z17unsigned_loop_sgejjj
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[GEP_UB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 1
; CHECK-NEXT:    [[GEP_LB_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 2
; CHECK-NEXT:    [[GEP_STEP_ADDR:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z17UNSIGNED_LOOP_SGEJJJ]], ptr [[TASK_ARGS]], i32 0, i32 3
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z17unsigned_loop_sgejjj(ptr [[GEP_I]], ptr [[GEP_UB_ADDR]], ptr [[GEP_LB_ADDR]], ptr [[GEP_STEP_ADDR]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_unpacked_task_region__Z14constants_loopv
; CHECK-SAME: (ptr [[I:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) !dbg [[DBG157:![0-9]+]] {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[TMP0:%.*]], !dbg [[DBG158:![0-9]+]]
; CHECK:       0:
; CHECK-NEXT:    [[LB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T:%.*]], ptr [[LOOP_BOUNDS]], i32 0, i32 0, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[LB_GEP]], align 8, !dbg [[DBG158]]
; CHECK-NEXT:    [[LB:%.*]] = trunc i64 [[TMP1]] to i32, !dbg [[DBG158]]
; CHECK-NEXT:    [[UB_GEP:%.*]] = getelementptr [[NANOS6_LOOP_BOUNDS_T]], ptr [[LOOP_BOUNDS]], i32 0, i32 1, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[UB_GEP]], align 8, !dbg [[DBG158]]
; CHECK-NEXT:    [[UB:%.*]] = trunc i64 [[TMP2]] to i32, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @compute_lb.22(), !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @compute_ub.23(), !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @compute_step.24(), !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[UB]], [[LB]], !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP7:%.*]] = sub i32 [[TMP6]], 1, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP8:%.*]] = sdiv i32 [[TMP7]], [[TMP5]], !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], 1, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64, !dbg [[DBG158]]
; CHECK-NEXT:    [[LOOP:%.*]] = alloca i32, align 4, !dbg [[DBG158]]
; CHECK-NEXT:    store i32 [[LB]], ptr [[LOOP]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    br label [[FOR_COND1:%.*]], !dbg [[DBG158]]
; CHECK:       for.cond1:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp slt i32 [[TMP11]], [[UB]], !dbg [[DBG158]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[DOTEXITSTUB:%.*]], !dbg [[DBG158]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP15:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i64 [[TMP15]], 1, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP17:%.*]] = sext i32 [[TMP5]] to i64, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i64 [[TMP16]], [[TMP17]], !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP19:%.*]] = sext i32 [[TMP3]] to i64, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP22:%.*]] = sext i32 [[TMP14]] to i64, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP22]], [[TMP21]], !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP24:%.*]] = trunc i64 [[TMP20]] to i32, !dbg [[DBG158]]
; CHECK-NEXT:    store i32 [[TMP24]], ptr [[I]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    br label [[FOR_BODY2:%.*]], !dbg [[DBG158]]
; CHECK:       for.body2:
; CHECK-NEXT:    br label [[FOR_INCR4:%.*]], !dbg [[DBG159:![0-9]+]]
; CHECK:       for.incr4:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, ptr [[LOOP]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG158]]
; CHECK-NEXT:    store i32 [[TMP26]], ptr [[LOOP]], align 4, !dbg [[DBG158]]
; CHECK-NEXT:    br label [[FOR_COND1]], !dbg [[DBG158]]
; CHECK:       .exitStub:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@nanos6_ol_task_region__Z14constants_loopv
; CHECK-SAME: (ptr [[TASK_ARGS:%.*]], ptr [[LOOP_BOUNDS:%.*]], ptr [[ADDRESS_TRANSLATION_TABLE:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP_I:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z14CONSTANTS_LOOPV:%.*]], ptr [[TASK_ARGS]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne ptr [[ADDRESS_TRANSLATION_TABLE]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP1:%.*]], label [[TMP2:%.*]]
; CHECK:       1:
; CHECK-NEXT:    br label [[TMP2]]
; CHECK:       2:
; CHECK-NEXT:    call void @nanos6_unpacked_task_region__Z14constants_loopv(ptr [[GEP_I]], ptr [[LOOP_BOUNDS]], ptr [[ADDRESS_TRANSLATION_TABLE]])
; CHECK-NEXT:    ret void
;
