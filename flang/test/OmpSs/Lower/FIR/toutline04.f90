! NOTE: Assertions have been autogenerated by /home/rpenacob/llvm-mono/mlir/utils/generate-test-checks.py
! RUN: bbc -fompss-2 -emit-fir %s -o - | FileCheck %s

! Based on Lower/dummy-argument-optional.f90

! Test OPTIONAL lowering on caller/callee and PRESENT intrinsic.
module opt
  implicit none
  type t
    real, allocatable :: p(:)
  end type
contains

! Test simple scalar optional
!$OSS TASK
subroutine intrinsic_scalar(x)
  real, optional :: x
  print *, present(x)
end subroutine
subroutine call_intrinsic_scalar()
  real :: x
  call intrinsic_scalar(x)
  call intrinsic_scalar()
end subroutine

! Test explicit shape array optional
!$OSS TASK
subroutine intrinsic_f77_array(x)
  real, optional :: x(100)
  print *, present(x)
end subroutine
subroutine call_intrinsic_f77_array()
  real :: x(100)
  call intrinsic_f77_array(x)
  call intrinsic_f77_array()
end subroutine

! Test optional assumed shape
!$OSS TASK
subroutine assumed_shape(x)
  real, optional :: x(:)
  print *, present(x)
end subroutine
subroutine call_assumed_shape()
  real :: x(100)
  call assumed_shape(x)
  call assumed_shape()
end subroutine

! Test optional allocatable
!$OSS TASK
subroutine allocatable_array(x)
  real, allocatable, optional :: x(:)
  print *, present(x)
end subroutine
subroutine call_allocatable_array()
  real, allocatable :: x(:)
  call allocatable_array(x)
  call allocatable_array()
end subroutine

subroutine allocatable_to_assumed_optional_array(x)
  real, allocatable :: x(:)

  call assumed_shape(x)
end subroutine

subroutine alloc_component_to_optional_assumed_shape(x)
  type(t) :: x(100)
  call assumed_shape(x(55)%p)
end subroutine

subroutine alloc_component_eval_only_once(x)
  integer, external :: ifoo
  type(t) :: x(100)
  ! Verify that the index in the component reference are not evaluated twice
  ! because if the optional handling logic.
  call assumed_shape(x(ifoo())%p)
end subroutine

subroutine null_as_optional
 call assumed_shape(null())
end subroutine null_as_optional

end module

! CHECK-LABEL:   func.func @_QMoptPintrinsic_scalar(
! CHECK-SAME:                                       %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<f32> {fir.bindc_name = "x", fir.optional}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = arith.constant -1 : i32
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.address_of(@_QQcl.{{.*}})
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_2]] : (!fir.ref<!fir.char<1,67>>) -> !fir.ref<i8>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.constant 18 : i32
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.call @_FortranAioBeginExternalListOutput(%[[VAL_1]], %[[VAL_3]], %[[VAL_4]]) fastmath<contract> : (i32, !fir.ref<i8>, i32) -> !fir.ref<i8>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.is_present %[[VAL_0]] : (!fir.ref<f32>) -> i1
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.call @_FortranAioOutputLogical(%[[VAL_5]], %[[VAL_6]]) fastmath<contract> : (!fir.ref<i8>, i1) -> i1
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.call @_FortranAioEndIoStatement(%[[VAL_5]]) fastmath<contract> : (!fir.ref<i8>) -> i32
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPcall_intrinsic_scalar() {
! CHECK:           %[[VAL_0:[-0-9A-Za-z._]+]] = fir.alloca f32 {bindc_name = "x", uniq_name = "_QMoptFcall_intrinsic_scalarEx"}
! CHECK:           oss.task shared(%[[VAL_0]] : !fir.ref<f32>) {
! CHECK:             fir.call @_QMoptPintrinsic_scalar(%[[VAL_0]]) fastmath<contract> : (!fir.ref<f32>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.absent !fir.ref<f32>
! CHECK:           oss.task shared(%[[VAL_1]] : !fir.ref<f32>) {
! CHECK:             fir.call @_QMoptPintrinsic_scalar(%[[VAL_1]]) fastmath<contract> : (!fir.ref<f32>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPintrinsic_f77_array(
! CHECK-SAME:                                          %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<!fir.array<100xf32>> {fir.bindc_name = "x", fir.optional}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = arith.constant -1 : i32
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.address_of(@_QQcl.{{.*}})
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_2]] : (!fir.ref<!fir.char<1,67>>) -> !fir.ref<i8>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.constant 30 : i32
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.call @_FortranAioBeginExternalListOutput(%[[VAL_1]], %[[VAL_3]], %[[VAL_4]]) fastmath<contract> : (i32, !fir.ref<i8>, i32) -> !fir.ref<i8>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.is_present %[[VAL_0]] : (!fir.ref<!fir.array<100xf32>>) -> i1
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.call @_FortranAioOutputLogical(%[[VAL_5]], %[[VAL_6]]) fastmath<contract> : (!fir.ref<i8>, i1) -> i1
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.call @_FortranAioEndIoStatement(%[[VAL_5]]) fastmath<contract> : (!fir.ref<i8>) -> i32
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPcall_intrinsic_f77_array() {
! CHECK:           %[[VAL_0:[-0-9A-Za-z._]+]] = arith.constant 100 : index
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.alloca !fir.array<100xf32> {bindc_name = "x", uniq_name = "_QMoptFcall_intrinsic_f77_arrayEx"}
! CHECK:           oss.task shared(%[[VAL_1]] : !fir.ref<!fir.array<100xf32>>) captures(%[[VAL_0]] : index) {
! CHECK:             fir.call @_QMoptPintrinsic_f77_array(%[[VAL_1]]) fastmath<contract> : (!fir.ref<!fir.array<100xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.absent !fir.ref<!fir.array<100xf32>>
! CHECK:           oss.task shared(%[[VAL_2]] : !fir.ref<!fir.array<100xf32>>) {
! CHECK:             fir.call @_QMoptPintrinsic_f77_array(%[[VAL_2]]) fastmath<contract> : (!fir.ref<!fir.array<100xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPassumed_shape(
! CHECK-SAME:                                    %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.box<!fir.array<?xf32>> {fir.bindc_name = "x", fir.optional}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = arith.constant -1 : i32
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.address_of(@_QQcl.{{.*}})
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_2]] : (!fir.ref<!fir.char<1,67>>) -> !fir.ref<i8>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.constant 42 : i32
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.call @_FortranAioBeginExternalListOutput(%[[VAL_1]], %[[VAL_3]], %[[VAL_4]]) fastmath<contract> : (i32, !fir.ref<i8>, i32) -> !fir.ref<i8>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.is_present %[[VAL_0]] : (!fir.box<!fir.array<?xf32>>) -> i1
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.call @_FortranAioOutputLogical(%[[VAL_5]], %[[VAL_6]]) fastmath<contract> : (!fir.ref<i8>, i1) -> i1
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.call @_FortranAioEndIoStatement(%[[VAL_5]]) fastmath<contract> : (!fir.ref<i8>) -> i32
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPcall_assumed_shape() {
! CHECK:           %[[VAL_0:[-0-9A-Za-z._]+]] = arith.constant 100 : index
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.alloca !fir.array<100xf32> {bindc_name = "x", uniq_name = "_QMoptFcall_assumed_shapeEx"}
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.shape %[[VAL_0]] : (index) -> !fir.shape<1>
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_1]](%[[VAL_2]]) : (!fir.ref<!fir.array<100xf32>>, !fir.shape<1>) -> !fir.box<!fir.array<100xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_3]] : !fir.box<!fir.array<100xf32>>) {
! CHECK:             %[[VAL_4:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_3]] : (!fir.box<!fir.array<100xf32>>) -> !fir.box<!fir.array<?xf32>>
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_4]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.absent !fir.box<!fir.array<?xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_5]] : !fir.box<!fir.array<?xf32>>) {
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_5]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPallocatable_array(
! CHECK-SAME:                                        %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>> {fir.bindc_name = "x", fir.optional}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = arith.constant -1 : i32
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.address_of(@_QQcl.{{.*}})
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_2]] : (!fir.ref<!fir.char<1,67>>) -> !fir.ref<i8>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.constant 54 : i32
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.call @_FortranAioBeginExternalListOutput(%[[VAL_1]], %[[VAL_3]], %[[VAL_4]]) fastmath<contract> : (i32, !fir.ref<i8>, i32) -> !fir.ref<i8>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.is_present %[[VAL_0]] : (!fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>) -> i1
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.call @_FortranAioOutputLogical(%[[VAL_5]], %[[VAL_6]]) fastmath<contract> : (!fir.ref<i8>, i1) -> i1
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.call @_FortranAioEndIoStatement(%[[VAL_5]]) fastmath<contract> : (!fir.ref<i8>) -> i32
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPcall_allocatable_array() {
! CHECK:           %[[VAL_0:[-0-9A-Za-z._]+]] = fir.alloca !fir.box<!fir.heap<!fir.array<?xf32>>> {bindc_name = "x", uniq_name = "_QMoptFcall_allocatable_arrayEx"}
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.zero_bits !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = arith.constant 0 : index
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.shape %[[VAL_2]] : (index) -> !fir.shape<1>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_1]](%[[VAL_3]]) : (!fir.heap<!fir.array<?xf32>>, !fir.shape<1>) -> !fir.box<!fir.heap<!fir.array<?xf32>>>
! CHECK:           fir.store %[[VAL_4]] to %[[VAL_0]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           oss.task shared(%[[VAL_0]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>) {
! CHECK:             fir.call @_QMoptPallocatable_array(%[[VAL_0]]) fastmath<contract> : (!fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.absent !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           oss.task shared(%[[VAL_5]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>) {
! CHECK:             fir.call @_QMoptPallocatable_array(%[[VAL_5]]) fastmath<contract> : (!fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPallocatable_to_assumed_optional_array(
! CHECK-SAME:                                                            %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>> {fir.bindc_name = "x"}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.load %[[VAL_0]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_1]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_2]] : (!fir.heap<!fir.array<?xf32>>) -> i64
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.constant 0 : i64
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = arith.cmpi ne, %[[VAL_3]], %[[VAL_4]] : i64
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.absent !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.load %[[VAL_0]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = arith.constant 0 : index
! CHECK:           %[[VAL_9:[-0-9A-Za-z._]+]]:3 = fir.box_dims %[[VAL_7]], %[[VAL_8]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>, index) -> (index, index, index)
! CHECK:           %[[VAL_10:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_7]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_11:[-0-9A-Za-z._]+]] = fir.shape_shift %[[VAL_9]]#0, %[[VAL_9]]#1 : (index, index) -> !fir.shapeshift<1>
! CHECK:           %[[VAL_12:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_10]](%[[VAL_11]]) : (!fir.heap<!fir.array<?xf32>>, !fir.shapeshift<1>) -> !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_13:[-0-9A-Za-z._]+]] = arith.select %[[VAL_5]], %[[VAL_12]], %[[VAL_6]] : !fir.box<!fir.array<?xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_13]] : !fir.box<!fir.array<?xf32>>) {
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_13]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPalloc_component_to_optional_assumed_shape(
! CHECK-SAME:                                                                %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<!fir.array<100x!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>> {fir.bindc_name = "x"}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = arith.constant 55 : i64
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = arith.constant 1 : i64
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = arith.subi %[[VAL_1]], %[[VAL_2]] : i64
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = fir.coordinate_of %[[VAL_0]], %[[VAL_3]] : (!fir.ref<!fir.array<100x!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>>, i64) -> !fir.ref<!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.field_index p, !fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.coordinate_of %[[VAL_4]], %[[VAL_5]] : (!fir.ref<!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>, !fir.field) -> !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.load %[[VAL_6]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_7]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_9:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_8]] : (!fir.heap<!fir.array<?xf32>>) -> i64
! CHECK:           %[[VAL_10:[-0-9A-Za-z._]+]] = arith.constant 0 : i64
! CHECK:           %[[VAL_11:[-0-9A-Za-z._]+]] = arith.cmpi ne, %[[VAL_9]], %[[VAL_10]] : i64
! CHECK:           %[[VAL_12:[-0-9A-Za-z._]+]] = fir.absent !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_13:[-0-9A-Za-z._]+]] = fir.load %[[VAL_6]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_14:[-0-9A-Za-z._]+]] = arith.constant 0 : index
! CHECK:           %[[VAL_15:[-0-9A-Za-z._]+]]:3 = fir.box_dims %[[VAL_13]], %[[VAL_14]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>, index) -> (index, index, index)
! CHECK:           %[[VAL_16:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_13]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_17:[-0-9A-Za-z._]+]] = fir.shape_shift %[[VAL_15]]#0, %[[VAL_15]]#1 : (index, index) -> !fir.shapeshift<1>
! CHECK:           %[[VAL_18:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_16]](%[[VAL_17]]) : (!fir.heap<!fir.array<?xf32>>, !fir.shapeshift<1>) -> !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_19:[-0-9A-Za-z._]+]] = arith.select %[[VAL_11]], %[[VAL_18]], %[[VAL_12]] : !fir.box<!fir.array<?xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_19]] : !fir.box<!fir.array<?xf32>>) {
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_19]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPalloc_component_eval_only_once(
! CHECK-SAME:                                                     %[[VAL_0:[-0-9A-Za-z._]+]]: !fir.ref<!fir.array<100x!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>> {fir.bindc_name = "x"}) {
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.call @_QPifoo() fastmath<contract> : () -> i32
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_1]] : (i32) -> i64
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = arith.constant 1 : i64
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = arith.subi %[[VAL_2]], %[[VAL_3]] : i64
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.coordinate_of %[[VAL_0]], %[[VAL_4]] : (!fir.ref<!fir.array<100x!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>>, i64) -> !fir.ref<!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = fir.field_index p, !fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = fir.coordinate_of %[[VAL_5]], %[[VAL_6]] : (!fir.ref<!fir.type<_QMoptTt{p:!fir.box<!fir.heap<!fir.array<?xf32>>>}>>, !fir.field) -> !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.load %[[VAL_7]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_9:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_8]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_10:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_9]] : (!fir.heap<!fir.array<?xf32>>) -> i64
! CHECK:           %[[VAL_11:[-0-9A-Za-z._]+]] = arith.constant 0 : i64
! CHECK:           %[[VAL_12:[-0-9A-Za-z._]+]] = arith.cmpi ne, %[[VAL_10]], %[[VAL_11]] : i64
! CHECK:           %[[VAL_13:[-0-9A-Za-z._]+]] = fir.absent !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_14:[-0-9A-Za-z._]+]] = fir.load %[[VAL_7]] : !fir.ref<!fir.box<!fir.heap<!fir.array<?xf32>>>>
! CHECK:           %[[VAL_15:[-0-9A-Za-z._]+]] = arith.constant 0 : index
! CHECK:           %[[VAL_16:[-0-9A-Za-z._]+]]:3 = fir.box_dims %[[VAL_14]], %[[VAL_15]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>, index) -> (index, index, index)
! CHECK:           %[[VAL_17:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_14]] : (!fir.box<!fir.heap<!fir.array<?xf32>>>) -> !fir.heap<!fir.array<?xf32>>
! CHECK:           %[[VAL_18:[-0-9A-Za-z._]+]] = fir.shape_shift %[[VAL_16]]#0, %[[VAL_16]]#1 : (index, index) -> !fir.shapeshift<1>
! CHECK:           %[[VAL_19:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_17]](%[[VAL_18]]) : (!fir.heap<!fir.array<?xf32>>, !fir.shapeshift<1>) -> !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_20:[-0-9A-Za-z._]+]] = arith.select %[[VAL_12]], %[[VAL_19]], %[[VAL_13]] : !fir.box<!fir.array<?xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_20]] : !fir.box<!fir.array<?xf32>>) {
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_20]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }

! CHECK-LABEL:   func.func @_QMoptPnull_as_optional() {
! CHECK:           %[[VAL_0:[-0-9A-Za-z._]+]] = fir.alloca !fir.box<!fir.ptr<none>>
! CHECK:           %[[VAL_1:[-0-9A-Za-z._]+]] = fir.zero_bits !fir.ptr<none>
! CHECK:           %[[VAL_2:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_1]] : (!fir.ptr<none>) -> !fir.box<!fir.ptr<none>>
! CHECK:           fir.store %[[VAL_2]] to %[[VAL_0]] : !fir.ref<!fir.box<!fir.ptr<none>>>
! CHECK:           %[[VAL_3:[-0-9A-Za-z._]+]] = fir.load %[[VAL_0]] : !fir.ref<!fir.box<!fir.ptr<none>>>
! CHECK:           %[[VAL_4:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_3]] : (!fir.box<!fir.ptr<none>>) -> !fir.ptr<none>
! CHECK:           %[[VAL_5:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_4]] : (!fir.ptr<none>) -> i64
! CHECK:           %[[VAL_6:[-0-9A-Za-z._]+]] = arith.constant 0 : i64
! CHECK:           %[[VAL_7:[-0-9A-Za-z._]+]] = arith.cmpi ne, %[[VAL_5]], %[[VAL_6]] : i64
! CHECK:           %[[VAL_8:[-0-9A-Za-z._]+]] = fir.absent !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_9:[-0-9A-Za-z._]+]] = fir.load %[[VAL_0]] : !fir.ref<!fir.box<!fir.ptr<none>>>
! CHECK:           %[[VAL_10:[-0-9A-Za-z._]+]] = fir.box_addr %[[VAL_9]] : (!fir.box<!fir.ptr<none>>) -> !fir.ptr<none>
! CHECK:           %[[VAL_11:[-0-9A-Za-z._]+]] = fir.embox %[[VAL_10]] : (!fir.ptr<none>) -> !fir.box<none>
! CHECK:           %[[VAL_12:[-0-9A-Za-z._]+]] = fir.convert %[[VAL_11]] : (!fir.box<none>) -> !fir.box<!fir.array<?xf32>>
! CHECK:           %[[VAL_13:[-0-9A-Za-z._]+]] = arith.select %[[VAL_7]], %[[VAL_12]], %[[VAL_8]] : !fir.box<!fir.array<?xf32>>
! CHECK:           oss.task firstprivate(%[[VAL_13]] : !fir.box<!fir.array<?xf32>>) {
! CHECK:             fir.call @_QMoptPassumed_shape(%[[VAL_13]]) fastmath<contract> : (!fir.box<!fir.array<?xf32>>) -> ()
! CHECK:             oss.terminator
! CHECK:           }
! CHECK:           return
! CHECK:         }
! CHECK:         func.func private @_FortranAioBeginExternalListOutput(i32, !fir.ref<i8>, i32) -> !fir.ref<i8> attributes {fir.io, fir.runtime}

