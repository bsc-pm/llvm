//===--- CGStmtOmpSs.cpp - Emit LLVM Code from Statements ----------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This contains code to emit OmpSs nodes as LLVM code.
//
//===----------------------------------------------------------------------===//

#include "CGCleanup.h"
#include "CGOmpSsRuntime.h"
#include "CodeGenFunction.h"
#include "CodeGenModule.h"
#include "TargetInfo.h"
#include "clang/AST/Stmt.h"
#include "clang/AST/StmtOmpSs.h"
using namespace clang;
using namespace CodeGen;

static void AddDSASharedData(const OSSExecutableDirective &S, SmallVectorImpl<const Expr *> &Data) {
  // All DSAs are DeclRefExpr or CXXThisExpr
  llvm::SmallSet<const ValueDecl *, 8> DeclExpr;
  for (const auto *C : S.getClausesOfKind<OSSSharedClause>()) {
    for (const Expr *Ref : C->varlists()) {
      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Ref)) {
        const ValueDecl *VD = DRE->getDecl();
        if (DeclExpr.insert(VD).second)
          Data.push_back(Ref);
      } else if (const CXXThisExpr *ThisE = dyn_cast<CXXThisExpr>(Ref)) {
        // 'this' expression is only allowed when it's generated by the compiler
        Data.push_back(ThisE);
      }
    }
  }
}

static void AddDSAPrivateData(const OSSExecutableDirective &S, SmallVectorImpl<OSSDSAPrivateDataTy> &PList) {
  // All DSA are DeclRefExpr
  llvm::SmallSet<const ValueDecl *, 8> DeclExpr;
  for (const auto *C : S.getClausesOfKind<OSSPrivateClause>()) {
    auto CopyRef = C->private_copies().begin();
    for (const Expr *Ref : C->varlists()) {
      const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Ref);
      const ValueDecl *VD = DRE->getDecl();
      // This assumes item i has a copyref and initref
      if (DeclExpr.insert(VD).second)
        PList.push_back({Ref, *CopyRef});

      ++CopyRef;
    }
  }
}

static void AddDSAFirstprivateData(const OSSExecutableDirective &S,
                                   SmallVectorImpl<OSSDSAFirstprivateDataTy> &FpList) {
  // All DSA are DeclRefExpr
  llvm::SmallSet<const ValueDecl *, 8> DeclExpr;
  for (const auto *C : S.getClausesOfKind<OSSFirstprivateClause>()) {
    auto CopyRef = C->private_copies().begin();
    auto InitRef = C->inits().begin();
    for (const Expr *Ref : C->varlists()) {
      const DeclRefExpr *DRE = cast<DeclRefExpr>(Ref);
      const ValueDecl *VD = DRE->getDecl();
      // This assumes item i has a copyref and initref
      if (DeclExpr.insert(VD).second)
        FpList.push_back({Ref, *CopyRef, *InitRef});

      ++CopyRef;
      ++InitRef;
    }
  }
}

static void AddDSAData(const OSSExecutableDirective &S, OSSTaskDSADataTy &DSAs) {
  AddDSASharedData(S, DSAs.Shareds);
  AddDSAPrivateData(S, DSAs.Privates);
  AddDSAFirstprivateData(S, DSAs.Firstprivates);
}

static void AddDepData(const OSSExecutableDirective &S, OSSTaskDepDataTy &Deps) {
  for (const auto *C : S.getClausesOfKind<OSSDependClause>()) {
    ArrayRef<OmpSsDependClauseKind> DepKindsOrdered = C->getDependencyKindsOrdered();
    if (DepKindsOrdered.size() == 2) {
      for (const Expr *Ref : C->varlists()) {
        if (DepKindsOrdered[0] == OSSC_DEPEND_in)
          Deps.WeakIns.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_out)
          Deps.WeakOuts.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_inout)
          Deps.WeakInouts.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_inoutset)
          Deps.WeakConcurrents.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_mutexinoutset)
          Deps.WeakCommutatives.push_back({C->isOSSSyntax(), Ref});
      }
    }
    else {
      for (const Expr *Ref : C->varlists()) {
        if (DepKindsOrdered[0] == OSSC_DEPEND_in)
          Deps.Ins.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_out)
          Deps.Outs.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_inout)
          Deps.Inouts.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_inoutset)
          Deps.Concurrents.push_back({C->isOSSSyntax(), Ref});
        if (DepKindsOrdered[0] == OSSC_DEPEND_mutexinoutset)
          Deps.Commutatives.push_back({C->isOSSSyntax(), Ref});
      }
    }
  }
}

static void AddIfData(const OSSExecutableDirective &S, const Expr *&IfExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSIfClause>()) {
    assert(!Found);
    Found = true;
    IfExpr = C->getCondition();
  }
}

static void AddFinalData(const OSSExecutableDirective &S, const Expr * &FinalExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSFinalClause>()) {
    assert(!Found);
    Found = true;
    FinalExpr = C->getCondition();
  }
}

static void AddCostData(const OSSExecutableDirective &S, const Expr * &CostExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSCostClause>()) {
    assert(!Found);
    Found = true;
    CostExpr = C->getExpression();
  }
}

static void AddPriorityData(const OSSExecutableDirective &S, const Expr * &PriorityExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSPriorityClause>()) {
    assert(!Found);
    Found = true;
    PriorityExpr = C->getExpression();
  }
}

static void AddLabelData(
    const OSSExecutableDirective &S, SmallVectorImpl<const Expr *> &Labels) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSLabelClause>()) {
    assert(!Found);
    Found = true;
    Labels.append(C->varlist_begin(), C->varlist_end());
  }
}

static void AddWaitData(const OSSExecutableDirective &S, bool &Wait) {
  assert(!Wait);
  Wait = !S.getClausesOfKind<OSSWaitClause>().empty();
}

static void AddUpdateLoopData(const OSSExecutableDirective &S, bool &Update) {
  assert(!Update);
  Update = !S.getClausesOfKind<OSSUpdateClause>().empty();
}

static void AddOnreadyData(const OSSExecutableDirective &S, const Expr * &OnreadyExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSOnreadyClause>()) {
    assert(!Found);
    Found = true;
    OnreadyExpr = C->getExpression();
  }
}

static void AddReductionData(const OSSExecutableDirective &S, OSSTaskReductionDataTy &Reductions) {
  for (const auto *C : S.getClausesOfKind<OSSReductionClause>()) {
    auto LHSRef = C->lhs_exprs().begin();
    auto RHSRef = C->rhs_exprs().begin();
    auto RedOp = C->reduction_ops().begin();
    auto RedKind = C->getReductionKinds().begin();
    if (!C->isWeak()) {
      for (const Expr *Ref : C->varlists()) {
        Reductions.RedList.push_back({Ref, *LHSRef, *RHSRef, *RedOp, *RedKind});
        ++LHSRef; ++RHSRef; ++RedOp; ++RedKind;
      }
    } else {
      for (const Expr *Ref : C->varlists()) {
        Reductions.WeakRedList.push_back({Ref, *LHSRef, *RHSRef, *RedOp, *RedKind});
        ++LHSRef; ++RHSRef; ++RedOp; ++RedKind;
      }
    }
  }
}

static void AddDeviceData(const OSSExecutableDirective &S, OSSTaskDeviceDataTy &Devices) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSDeviceClause>()) {
    assert(!Found);
    Found = true;
    Devices.DvKind = C->getDeviceKind();
  }
  if (!S.getClausesOfKind<OSSNdrangeClause>().empty())
    llvm_unreachable("Ndrange is not supported in inline constructs");
}

// Convenience function to add all info from a task directive
static void AddTaskData(const OSSExecutableDirective &S, OSSTaskDataTy &TaskData) {
  AddDSAData(S, TaskData.DSAs);
  AddDepData(S, TaskData.Deps);
  AddIfData(S, TaskData.If);
  AddFinalData(S, TaskData.Final);
  AddCostData(S, TaskData.Cost);
  AddPriorityData(S, TaskData.Priority);
  AddLabelData(S, TaskData.Labels);
  AddWaitData(S, TaskData.Wait);
  AddOnreadyData(S, TaskData.Onready);
  AddReductionData(S, TaskData.Reductions);
  AddDeviceData(S, TaskData.Devices);
}

static void AddChunksizeLoopData(const OSSLoopDirective &S, const Expr * &ChunksizeExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSChunksizeClause>()) {
    assert(!Found);
    Found = true;
    ChunksizeExpr = C->getExpression();
  }
}

static void AddGrainsizeLoopData(const OSSLoopDirective &S, const Expr * &GrainsizeExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSGrainsizeClause>()) {
    assert(!Found);
    Found = true;
    GrainsizeExpr = C->getExpression();
  }
}

static void AddUnrollLoopData(const OSSLoopDirective &S, const Expr * &UnrollExpr) {
  bool Found = false;
  for (const auto *C : S.getClausesOfKind<OSSUnrollClause>()) {
    assert(!Found);
    Found = true;
    UnrollExpr = C->getExpression();
  }
}

// Convenience function to add all info from a loop directive
static void AddLoopData(const OSSLoopDirective &S, OSSLoopDataTy &LoopData) {
  LoopData.IndVar = S.getIterationVariable();
  LoopData.LB = S.getLowerBound();
  LoopData.UB = S.getUpperBound();
  LoopData.Step = S.getStep();
  LoopData.TestIsLessOp = S.getIsLessOp();
  LoopData.TestIsStrictOp = S.getIsStrictOp();
  LoopData.NumCollapses = S.getNumCollapses();
  AddChunksizeLoopData(S, LoopData.Chunksize);
  AddGrainsizeLoopData(S, LoopData.Grainsize);
  AddUnrollLoopData(S, LoopData.Unroll);
  AddUpdateLoopData(S, LoopData.Update);
}

void CodeGenFunction::EmitOSSTaskwaitDirective(const OSSTaskwaitDirective &S) {
  OSSTaskDataTy Data;

  AddDSAData(S, Data.DSAs);
  AddDepData(S, Data.Deps);
  CGM.getOmpSsRuntime().emitTaskwaitCall(*this, S.getBeginLoc(), Data);
}

void CodeGenFunction::EmitOSSReleaseDirective(const OSSReleaseDirective &S) {
  OSSTaskDataTy Data;

  AddDepData(S, Data.Deps);
  CGM.getOmpSsRuntime().emitReleaseCall(*this, S.getBeginLoc(), Data);
}

void CodeGenFunction::EmitOSSTaskDirective(const OSSTaskDirective &S) {
  OSSTaskDataTy Data;

  AddTaskData(S, Data);

  CGM.getOmpSsRuntime().emitTaskCall(*this, S, S.getBeginLoc(), Data);
}

void CodeGenFunction::EmitOSSTaskForDirective(const OSSTaskForDirective &S) {
  OSSTaskDataTy Data;
  OSSLoopDataTy LoopData;

  AddTaskData(S, Data);
  AddLoopData(S, LoopData);

  CGM.getOmpSsRuntime().emitLoopCall(*this, S, S.getBeginLoc(), Data, LoopData);
}

void CodeGenFunction::EmitOSSTaskIterDirective(const OSSTaskIterDirective &S) {
  OSSTaskDataTy Data;
  OSSLoopDataTy LoopData;

  AddTaskData(S, Data);
  AddLoopData(S, LoopData);

  CGM.getOmpSsRuntime().emitLoopCall(*this, S, S.getBeginLoc(), Data, LoopData);
}

void CodeGenFunction::EmitOSSTaskLoopDirective(const OSSTaskLoopDirective &S) {
  OSSTaskDataTy Data;
  OSSLoopDataTy LoopData;

  AddTaskData(S, Data);
  AddLoopData(S, LoopData);

  CGM.getOmpSsRuntime().emitLoopCall(*this, S, S.getBeginLoc(), Data, LoopData);
}

void CodeGenFunction::EmitOSSTaskLoopForDirective(const OSSTaskLoopForDirective &S) {
  OSSTaskDataTy Data;
  OSSLoopDataTy LoopData;

  AddTaskData(S, Data);
  AddLoopData(S, LoopData);

  CGM.getOmpSsRuntime().emitLoopCall(*this, S, S.getBeginLoc(), Data, LoopData);
}

