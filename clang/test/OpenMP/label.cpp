// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
// RUN: %clang_cc1 -emit-llvm -o - -fopenmp -fopenmp-nosv %s | FileCheck %s
void foo() {
  #pragma omp parallel
  #pragma omp for label("s0")
  for (int i = 0; i < 100; ++i)
  {}
}

template<const char *str>
void bar() {
  #pragma omp parallel
  #pragma omp for label(str)
  for (int i = 0; i < 100; ++i)
  {}
}

const char asdf[] = "s1";

int main() {
  bar<asdf>();
}
// CHECK-LABEL: define {{[^@]+}}@_Z3foov
// CHECK-SAME: () #[[ATTR0:[0-9]+]] !dbg [[DBG6:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB7:[0-9]+]], i32 0, ptr @_Z3foov.omp_outlined), !dbg [[DBG10:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG11:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3foov.omp_outlined
// CHECK-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]]) #[[ATTR1:[0-9]+]] !dbg [[DBG12:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG13:![0-9]+]]
// CHECK-NEXT:    store i32 99, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG14:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4, !dbg [[DBG14]]
// CHECK-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB2:[0-9]+]], i32 [[TMP1]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1, ptr @[[GLOB0:[0-9]+]]), !dbg [[DBG14]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 99, !dbg [[DBG13]]
// CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG13]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG13]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    br label [[COND_END]], !dbg [[DBG13]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 99, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ], !dbg [[DBG13]]
// CHECK-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 [[TMP4]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.cond:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]], !dbg [[DBG15:![0-9]+]]
// CHECK-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.body:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1, !dbg [[DBG16:![0-9]+]]
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]], !dbg [[DBG16]]
// CHECK-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG16]]
// CHECK-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG17:![0-9]+]]
// CHECK:       omp.body.continue:
// CHECK-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.inc:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP8]], 1, !dbg [[DBG15]]
// CHECK-NEXT:    store i32 [[ADD2]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG15]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG14]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK:       omp.inner.for.end:
// CHECK-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG14]]
// CHECK:       omp.loop.exit:
// CHECK-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB4:[0-9]+]], i32 [[TMP1]], ptr @[[GLOB0]]), !dbg [[DBG19:![0-9]+]]
// CHECK-NEXT:    call void @__kmpc_barrier(ptr @[[GLOB5:[0-9]+]], i32 [[TMP1]]), !dbg [[DBG19]]
// CHECK-NEXT:    ret void, !dbg [[DBG19]]
//
//
// CHECK-LABEL: define {{[^@]+}}@__nosv_ctor_register_task_info() {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @__nosvc_register_task_info(ptr @[[GLOB0]], ptr @.str)
// CHECK-NEXT:    call void @__nosvc_register_task_info(ptr @[[GLOB8:[0-9]+]], ptr @_ZL4asdf)
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@main
// CHECK-SAME: () #[[ATTR4:[0-9]+]] !dbg [[DBG22:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @_Z3barIXadsoKcL_ZL4asdfEEEEvv(), !dbg [[DBG23:![0-9]+]]
// CHECK-NEXT:    ret i32 0, !dbg [[DBG24:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3barIXadsoKcL_ZL4asdfEEEEvv
// CHECK-SAME: () #[[ATTR0]] !dbg [[DBG25:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB15:[0-9]+]], i32 0, ptr @_Z3barIXadsoKcL_ZL4asdfEEEEvv.omp_outlined), !dbg [[DBG26:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG27:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3barIXadsoKcL_ZL4asdfEEEEvv.omp_outlined
// CHECK-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]]) #[[ATTR1]] !dbg [[DBG28:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG29:![0-9]+]]
// CHECK-NEXT:    store i32 99, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG30:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4, !dbg [[DBG30]]
// CHECK-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB10:[0-9]+]], i32 [[TMP1]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1, ptr @[[GLOB8]]), !dbg [[DBG30]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 99, !dbg [[DBG29]]
// CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG29]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG29]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    br label [[COND_END]], !dbg [[DBG29]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 99, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ], !dbg [[DBG29]]
// CHECK-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 [[TMP4]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.cond:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]], !dbg [[DBG31:![0-9]+]]
// CHECK-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.body:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1, !dbg [[DBG32:![0-9]+]]
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]], !dbg [[DBG32]]
// CHECK-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG32]]
// CHECK-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG33:![0-9]+]]
// CHECK:       omp.body.continue:
// CHECK-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.inc:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP8]], 1, !dbg [[DBG31]]
// CHECK-NEXT:    store i32 [[ADD2]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG31]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG30]], !llvm.loop [[LOOP34:![0-9]+]]
// CHECK:       omp.inner.for.end:
// CHECK-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG30]]
// CHECK:       omp.loop.exit:
// CHECK-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB12:[0-9]+]], i32 [[TMP1]], ptr @[[GLOB8]]), !dbg [[DBG35:![0-9]+]]
// CHECK-NEXT:    call void @__kmpc_barrier(ptr @[[GLOB13:[0-9]+]], i32 [[TMP1]]), !dbg [[DBG35]]
// CHECK-NEXT:    ret void, !dbg [[DBG35]]
//
