// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --check-globals --include-generated-funcs
// RUN: %clang_cc1 -emit-llvm -o - -fopenmp %s | FileCheck %s
void foo() {
  #pragma omp parallel
  #pragma omp for label("s0")
  for (int i = 0; i < 100; ++i)
  {}
}

template<const char *str>
void bar() {
  #pragma omp parallel
  #pragma omp for label(str)
  for (int i = 0; i < 100; ++i)
  {}
}

const char asdf[] = "s1";

int main() {
  bar<asdf>();
}
//.
// CHECK: @0 = internal global ptr null
// CHECK: @.str = private unnamed_addr constant [3 x i8] c"s0\00", align 1
// CHECK: @1 = private unnamed_addr constant [21 x i8] c"
// CHECK: @2 = private unnamed_addr constant %struct.ident_t { i32 0, i32 514, i32 0, i32 20, ptr @1 }, align 8
// CHECK: @3 = private unnamed_addr constant [22 x i8] c"
// CHECK: @4 = private unnamed_addr constant %struct.ident_t { i32 0, i32 514, i32 0, i32 21, ptr @3 }, align 8
// CHECK: @5 = private unnamed_addr constant %struct.ident_t { i32 0, i32 66, i32 0, i32 20, ptr @1 }, align 8
// CHECK: @6 = private unnamed_addr constant [21 x i8] c"
// CHECK: @7 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 20, ptr @6 }, align 8
// CHECK: @8 = internal global ptr null
// CHECK: @_ZL4asdf = internal constant [3 x i8] c"s1\00", align 1
// CHECK: @9 = private unnamed_addr constant [22 x i8] c"
// CHECK: @10 = private unnamed_addr constant %struct.ident_t { i32 0, i32 514, i32 0, i32 21, ptr @9 }, align 8
// CHECK: @11 = private unnamed_addr constant [23 x i8] c"
// CHECK: @12 = private unnamed_addr constant %struct.ident_t { i32 0, i32 514, i32 0, i32 22, ptr @11 }, align 8
// CHECK: @13 = private unnamed_addr constant %struct.ident_t { i32 0, i32 66, i32 0, i32 21, ptr @9 }, align 8
// CHECK: @14 = private unnamed_addr constant [22 x i8] c"
// CHECK: @15 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 21, ptr @14 }, align 8
// CHECK: @llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__kmp_ctor_register_task_info, ptr null }]
//.
// CHECK-LABEL: define {{[^@]+}}@_Z3foov
// CHECK-SAME: () #[[ATTR0:[0-9]+]] !dbg [[DBG6:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB7:[0-9]+]], i32 0, ptr @_Z3foov.omp_outlined), !dbg [[DBG10:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG11:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3foov.omp_outlined
// CHECK-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]]) #[[ATTR1:[0-9]+]] !dbg [[DBG12:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG13:![0-9]+]]
// CHECK-NEXT:    store i32 99, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG14:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4, !dbg [[DBG14]]
// CHECK-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB2:[0-9]+]], i32 [[TMP1]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1, ptr @[[GLOB0:[0-9]+]]), !dbg [[DBG14]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 99, !dbg [[DBG13]]
// CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG13]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG13]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    br label [[COND_END]], !dbg [[DBG13]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 99, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ], !dbg [[DBG13]]
// CHECK-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    store i32 [[TMP4]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.cond:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]], !dbg [[DBG15:![0-9]+]]
// CHECK-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.body:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1, !dbg [[DBG16:![0-9]+]]
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]], !dbg [[DBG16]]
// CHECK-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG16]]
// CHECK-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG17:![0-9]+]]
// CHECK:       omp.body.continue:
// CHECK-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG14]]
// CHECK:       omp.inner.for.inc:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG13]]
// CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP8]], 1, !dbg [[DBG15]]
// CHECK-NEXT:    store i32 [[ADD2]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG15]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG14]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK:       omp.inner.for.end:
// CHECK-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG14]]
// CHECK:       omp.loop.exit:
// CHECK-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB4:[0-9]+]], i32 [[TMP1]], ptr @[[GLOB0]]), !dbg [[DBG19:![0-9]+]]
// CHECK-NEXT:    call void @__kmpc_barrier(ptr @[[GLOB5:[0-9]+]], i32 [[TMP1]]), !dbg [[DBG19]]
// CHECK-NEXT:    ret void, !dbg [[DBG19]]
//
//
// CHECK-LABEL: define {{[^@]+}}@__kmp_ctor_register_task_info() {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @__kmpc_register_task_info(ptr @[[GLOB0]], ptr @.str)
// CHECK-NEXT:    call void @__kmpc_register_task_info(ptr @[[GLOB8:[0-9]+]], ptr @_ZL4asdf)
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@main
// CHECK-SAME: () #[[ATTR4:[0-9]+]] !dbg [[DBG22:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @_Z3barIXadsoKcL_ZL4asdfEEEEvv(), !dbg [[DBG23:![0-9]+]]
// CHECK-NEXT:    ret i32 0, !dbg [[DBG24:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3barIXadsoKcL_ZL4asdfEEEEvv
// CHECK-SAME: () #[[ATTR0]] !dbg [[DBG25:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB15:[0-9]+]], i32 0, ptr @_Z3barIXadsoKcL_ZL4asdfEEEEvv.omp_outlined), !dbg [[DBG26:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG27:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3barIXadsoKcL_ZL4asdfEEEEvv.omp_outlined
// CHECK-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]]) #[[ATTR1]] !dbg [[DBG28:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG29:![0-9]+]]
// CHECK-NEXT:    store i32 99, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG30:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4, !dbg [[DBG30]]
// CHECK-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB10:[0-9]+]], i32 [[TMP1]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1, ptr @[[GLOB8]]), !dbg [[DBG30]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP2]], 99, !dbg [[DBG29]]
// CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG29]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG29]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    br label [[COND_END]], !dbg [[DBG29]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 99, [[COND_TRUE]] ], [ [[TMP3]], [[COND_FALSE]] ], !dbg [[DBG29]]
// CHECK-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    store i32 [[TMP4]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.cond:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP5]], [[TMP6]], !dbg [[DBG31:![0-9]+]]
// CHECK-NEXT:    br i1 [[CMP1]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.body:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP7]], 1, !dbg [[DBG32:![0-9]+]]
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]], !dbg [[DBG32]]
// CHECK-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG32]]
// CHECK-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG33:![0-9]+]]
// CHECK:       omp.body.continue:
// CHECK-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG30]]
// CHECK:       omp.inner.for.inc:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP8]], 1, !dbg [[DBG31]]
// CHECK-NEXT:    store i32 [[ADD2]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG31]]
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG30]], !llvm.loop [[LOOP34:![0-9]+]]
// CHECK:       omp.inner.for.end:
// CHECK-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG30]]
// CHECK:       omp.loop.exit:
// CHECK-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB12:[0-9]+]], i32 [[TMP1]], ptr @[[GLOB8]]), !dbg [[DBG35:![0-9]+]]
// CHECK-NEXT:    call void @__kmpc_barrier(ptr @[[GLOB13:[0-9]+]], i32 [[TMP1]]), !dbg [[DBG35]]
// CHECK-NEXT:    ret void, !dbg [[DBG35]]
//
//.
// CHECK: attributes #0 = { mustprogress noinline nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #1 = { noinline norecurse nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #2 = { nounwind }
// CHECK: attributes #3 = { convergent nounwind }
// CHECK: attributes #4 = { mustprogress noinline norecurse nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
//.
// CHECK: !0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "clang version 18.0.0 (git@bscpm03.bsc.es:llvm-ompss/llvm-mono.git 89b39a15efe901573b7b88ab0c8b6a6aaac26d1b)", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug, splitDebugInlining: false, nameTableKind: None)
// CHECK: !1 = !DIFile(filename: "<stdin>", directory: "/home/rpenacob/llvm-nosv/clang/test/OpenMP")
// CHECK: !2 = !{i32 2, !"Debug Info Version", i32 3}
// CHECK: !3 = !{i32 1, !"wchar_size", i32 4}
// CHECK: !4 = !{i32 7, !"openmp", i32 51}
// CHECK: !5 = !{!"clang version 18.0.0 (git@bscpm03.bsc.es:llvm-ompss/llvm-mono.git 89b39a15efe901573b7b88ab0c8b6a6aaac26d1b)"}
// CHECK: !6 = distinct !DISubprogram(name: "foo", scope: !7, file: !7, line: 3, type: !8, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0)
// CHECK: !7 = !DIFile(filename: "label.cpp", directory: "/home/rpenacob/llvm-nosv/clang/test/OpenMP")
// CHECK: !8 = !DISubroutineType(types: !9)
// CHECK: !9 = !{}
// CHECK: !10 = !DILocation(line: 4, column: 3, scope: !6)
// CHECK: !11 = !DILocation(line: 8, column: 1, scope: !6)
// CHECK: !12 = distinct !DISubprogram(name: "_Z3foov.omp_outlined", scope: !7, file: !7, line: 4, type: !8, scopeLine: 4, flags: DIFlagArtificial | DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0)
// CHECK: !13 = !DILocation(line: 6, column: 8, scope: !12)
// CHECK: !14 = !DILocation(line: 5, column: 3, scope: !12)
// CHECK: !15 = !DILocation(line: 6, column: 3, scope: !12)
// CHECK: !16 = !DILocation(line: 6, column: 28, scope: !12)
// CHECK: !17 = !DILocation(line: 7, column: 4, scope: !12)
// CHECK: !18 = distinct !{!18, !14, !19}
// CHECK: !19 = !DILocation(line: 5, column: 30, scope: !12)
// CHECK: !20 = !{!21}
// CHECK: !21 = !{i64 2, i64 -1, i64 -1, i1 true}
// CHECK: !22 = distinct !DISubprogram(name: "main", scope: !7, file: !7, line: 20, type: !8, scopeLine: 20, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0)
// CHECK: !23 = !DILocation(line: 21, column: 3, scope: !22)
// CHECK: !24 = !DILocation(line: 22, column: 1, scope: !22)
// CHECK: !25 = distinct !DISubprogram(name: "bar<asdf>", scope: !7, file: !7, line: 11, type: !8, scopeLine: 11, flags: DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0)
// CHECK: !26 = !DILocation(line: 12, column: 3, scope: !25)
// CHECK: !27 = !DILocation(line: 16, column: 1, scope: !25)
// CHECK: !28 = distinct !DISubprogram(name: "_Z3barIXadsoKcL_ZL4asdfEEEEvv.omp_outlined", scope: !7, file: !7, line: 12, type: !8, scopeLine: 12, flags: DIFlagArtificial | DIFlagPrototyped, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !0)
// CHECK: !29 = !DILocation(line: 14, column: 8, scope: !28)
// CHECK: !30 = !DILocation(line: 13, column: 3, scope: !28)
// CHECK: !31 = !DILocation(line: 14, column: 3, scope: !28)
// CHECK: !32 = !DILocation(line: 14, column: 28, scope: !28)
// CHECK: !33 = !DILocation(line: 15, column: 4, scope: !28)
// CHECK: !34 = distinct !{!34, !30, !35}
// CHECK: !35 = !DILocation(line: 13, column: 29, scope: !28)
//.
