// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
// RUN: %clang_cc1 -no-opaque-pointers -verify -disable-llvm-passes -fompss-2 -fexceptions -fcxx-exceptions -S -emit-llvm %s -o - | FileCheck %s
// expected-no-diagnostics

int a;
int b;

struct St {
  unsigned long field;
  St() {}
  ~St() {}
  int &get() { return a; }
};

void parallel_atomic_ewc() {
  St s;
#pragma oss task shared(s)
  {
#pragma oss atomic read
      b = St().get();
#pragma oss atomic write
      St().get() = b;
#pragma oss atomic
      St().get() %= b;
#pragma oss atomic
      s.field++;
#pragma oss atomic capture
      a = St().get() %= b;
    }
}

int &foo() { extern void mayThrow(); mayThrow(); return a; }

void parallel_atomic() {
#pragma oss task
  {
#pragma oss atomic read
    foo() = a;
#pragma oss atomic write
    a = foo();
#pragma oss atomic update
    a += foo();
#pragma oss atomic capture
    {b = a; a += foo(); }
  }
}
// CHECK-LABEL: define {{[^@]+}}@_Z19parallel_atomic_ewcv
// CHECK-SAME: () #[[ATTR0:[0-9]+]] personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) !dbg [[DBG5:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_ST:%.*]], align 8
// CHECK-NEXT:    call void @_ZN2StC1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[S]]), !dbg [[DBG9:![0-9]+]]
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.SHARED"(%struct.St* [[S]], [[STRUCT_ST]] undef), "QUAL.OSS.SHARED"(i32* @b, i32 undef), "QUAL.OSS.SHARED"(i32* @a, i32 undef) ], !dbg [[DBG10:![0-9]+]]
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_ST]], align 8
// CHECK-NEXT:    [[REF_TMP2:%.*]] = alloca [[STRUCT_ST]], align 8
// CHECK-NEXT:    [[REF_TMP6:%.*]] = alloca [[STRUCT_ST]], align 8
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[REF_TMP11:%.*]] = alloca [[STRUCT_ST]], align 8
// CHECK-NEXT:    [[ATOMIC_TEMP17:%.*]] = alloca i32, align 4
// CHECK-NEXT:    invoke void @_ZN2StC1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP]])
// CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[TERMINATE_LPAD:%.*]], !dbg [[DBG11:![0-9]+]]
// CHECK:       invoke.cont:
// CHECK-NEXT:    [[CALL:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_ZN2St3getEv(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP]])
// CHECK-NEXT:    to label [[INVOKE_CONT1:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG12:![0-9]+]]
// CHECK:       invoke.cont1:
// CHECK-NEXT:    [[ATOMIC_LOAD:%.*]] = load atomic i32, i32* [[CALL]] monotonic, align 4, !dbg [[DBG13:![0-9]+]]
// CHECK-NEXT:    store i32 [[ATOMIC_LOAD]], i32* @b, align 4, !dbg [[DBG13]]
// CHECK-NEXT:    call void @_ZN2StD1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP]]) #[[ATTR2:[0-9]+]], !dbg [[DBG14:![0-9]+]]
// CHECK-NEXT:    invoke void @_ZN2StC1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP2]])
// CHECK-NEXT:    to label [[INVOKE_CONT3:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG15:![0-9]+]]
// CHECK:       invoke.cont3:
// CHECK-NEXT:    [[CALL5:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_ZN2St3getEv(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP2]])
// CHECK-NEXT:    to label [[INVOKE_CONT4:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG16:![0-9]+]]
// CHECK:       invoke.cont4:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* @b, align 4, !dbg [[DBG17:![0-9]+]]
// CHECK-NEXT:    store atomic i32 [[TMP1]], i32* [[CALL5]] monotonic, align 4, !dbg [[DBG15]]
// CHECK-NEXT:    call void @_ZN2StD1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP2]]) #[[ATTR2]], !dbg [[DBG18:![0-9]+]]
// CHECK-NEXT:    invoke void @_ZN2StC1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP6]])
// CHECK-NEXT:    to label [[INVOKE_CONT7:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG19:![0-9]+]]
// CHECK:       invoke.cont7:
// CHECK-NEXT:    [[CALL9:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_ZN2St3getEv(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP6]])
// CHECK-NEXT:    to label [[INVOKE_CONT8:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG20:![0-9]+]]
// CHECK:       invoke.cont8:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* @b, align 4, !dbg [[DBG21:![0-9]+]]
// CHECK-NEXT:    [[ATOMIC_LOAD10:%.*]] = load atomic i32, i32* [[CALL9]] monotonic, align 4, !dbg [[DBG19]]
// CHECK-NEXT:    br label [[ATOMIC_CONT:%.*]], !dbg [[DBG19]]
// CHECK:       atomic_cont:
// CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ [[ATOMIC_LOAD10]], [[INVOKE_CONT8]] ], [ [[TMP6:%.*]], [[ATOMIC_CONT]] ], !dbg [[DBG19]]
// CHECK-NEXT:    [[REM:%.*]] = srem i32 [[TMP3]], [[TMP2]], !dbg [[DBG22:![0-9]+]]
// CHECK-NEXT:    store i32 [[REM]], i32* [[ATOMIC_TEMP]], align 4, !dbg [[DBG19]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32* [[ATOMIC_TEMP]], align 4, !dbg [[DBG19]]
// CHECK-NEXT:    [[TMP5:%.*]] = cmpxchg i32* [[CALL9]], i32 [[TMP3]], i32 [[TMP4]] monotonic monotonic, align 4, !dbg [[DBG19]]
// CHECK-NEXT:    [[TMP6]] = extractvalue { i32, i1 } [[TMP5]], 0, !dbg [[DBG19]]
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { i32, i1 } [[TMP5]], 1, !dbg [[DBG19]]
// CHECK-NEXT:    br i1 [[TMP7]], label [[ATOMIC_EXIT:%.*]], label [[ATOMIC_CONT]], !dbg [[DBG19]]
// CHECK:       atomic_exit:
// CHECK-NEXT:    call void @_ZN2StD1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP6]]) #[[ATTR2]], !dbg [[DBG23:![0-9]+]]
// CHECK-NEXT:    [[FIELD:%.*]] = getelementptr inbounds [[STRUCT_ST]], %struct.St* [[S]], i32 0, i32 0, !dbg [[DBG24:![0-9]+]]
// CHECK-NEXT:    [[TMP8:%.*]] = atomicrmw add i64* [[FIELD]], i64 1 monotonic, align 8, !dbg [[DBG25:![0-9]+]]
// CHECK-NEXT:    invoke void @_ZN2StC1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP11]])
// CHECK-NEXT:    to label [[INVOKE_CONT12:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG26:![0-9]+]]
// CHECK:       invoke.cont12:
// CHECK-NEXT:    [[CALL14:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_ZN2St3getEv(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP11]])
// CHECK-NEXT:    to label [[INVOKE_CONT13:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG27:![0-9]+]]
// CHECK:       invoke.cont13:
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, i32* @b, align 4, !dbg [[DBG28:![0-9]+]]
// CHECK-NEXT:    [[ATOMIC_LOAD15:%.*]] = load atomic i32, i32* [[CALL14]] monotonic, align 4, !dbg [[DBG29:![0-9]+]]
// CHECK-NEXT:    br label [[ATOMIC_CONT16:%.*]], !dbg [[DBG29]]
// CHECK:       atomic_cont16:
// CHECK-NEXT:    [[TMP10:%.*]] = phi i32 [ [[ATOMIC_LOAD15]], [[INVOKE_CONT13]] ], [ [[TMP13:%.*]], [[ATOMIC_CONT16]] ], !dbg [[DBG29]]
// CHECK-NEXT:    [[REM18:%.*]] = srem i32 [[TMP10]], [[TMP9]], !dbg [[DBG30:![0-9]+]]
// CHECK-NEXT:    store i32 [[REM18]], i32* [[ATOMIC_TEMP17]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32* [[ATOMIC_TEMP17]], align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP12:%.*]] = cmpxchg i32* [[CALL14]], i32 [[TMP10]], i32 [[TMP11]] monotonic monotonic, align 4, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP13]] = extractvalue { i32, i1 } [[TMP12]], 0, !dbg [[DBG29]]
// CHECK-NEXT:    [[TMP14:%.*]] = extractvalue { i32, i1 } [[TMP12]], 1, !dbg [[DBG29]]
// CHECK-NEXT:    br i1 [[TMP14]], label [[ATOMIC_EXIT19:%.*]], label [[ATOMIC_CONT16]], !dbg [[DBG29]]
// CHECK:       atomic_exit19:
// CHECK-NEXT:    store i32 [[REM18]], i32* @a, align 4, !dbg [[DBG29]]
// CHECK-NEXT:    call void @_ZN2StD1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[REF_TMP11]]) #[[ATTR2]], !dbg [[DBG31:![0-9]+]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]), !dbg [[DBG32:![0-9]+]]
// CHECK-NEXT:    call void @_ZN2StD1Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[S]]) #[[ATTR2]], !dbg [[DBG33:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG33]]
// CHECK:       terminate.lpad:
// CHECK-NEXT:    [[TMP15:%.*]] = landingpad { i8*, i32 }
// CHECK-NEXT:    catch i8* null, !dbg [[DBG11]]
// CHECK-NEXT:    [[TMP16:%.*]] = extractvalue { i8*, i32 } [[TMP15]], 0, !dbg [[DBG11]]
// CHECK-NEXT:    call void @__clang_call_terminate(i8* [[TMP16]]) #[[ATTR7:[0-9]+]], !dbg [[DBG11]]
// CHECK-NEXT:    unreachable, !dbg [[DBG11]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2StC1Ev
// CHECK-SAME: (%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr #[[ATTR1:[0-9]+]] comdat align 2 !dbg [[DBG34:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.St*, align 8
// CHECK-NEXT:    store %struct.St* [[THIS]], %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load %struct.St*, %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN2StC2Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS1]]), !dbg [[DBG35:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG36:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@__clang_call_terminate
// CHECK-SAME: (i8* noundef [[TMP0:%.*]]) #[[ATTR3:[0-9]+]] comdat {
// CHECK-NEXT:    [[TMP2:%.*]] = call i8* @__cxa_begin_catch(i8* [[TMP0]]) #[[ATTR2]]
// CHECK-NEXT:    call void @_ZSt9terminatev() #[[ATTR7]]
// CHECK-NEXT:    unreachable
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2St3getEv
// CHECK-SAME: (%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) #[[ATTR4:[0-9]+]] comdat align 2 !dbg [[DBG37:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.St*, align 8
// CHECK-NEXT:    store %struct.St* [[THIS]], %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load %struct.St*, %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret i32* @a, !dbg [[DBG38:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2StD1Ev
// CHECK-SAME: (%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr #[[ATTR5:[0-9]+]] comdat align 2 !dbg [[DBG39:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.St*, align 8
// CHECK-NEXT:    store %struct.St* [[THIS]], %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load %struct.St*, %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN2StD2Ev(%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS1]]) #[[ATTR2]], !dbg [[DBG40:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG41:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3foov
// CHECK-SAME: () #[[ATTR0]] !dbg [[DBG42:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @_Z8mayThrowv(), !dbg [[DBG43:![0-9]+]]
// CHECK-NEXT:    ret i32* @a, !dbg [[DBG44:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z15parallel_atomicv
// CHECK-SAME: () #[[ATTR4]] personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) !dbg [[DBG45:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.SHARED"(i32* @a, i32 undef), "QUAL.OSS.SHARED"(i32* @b, i32 undef) ], !dbg [[DBG46:![0-9]+]]
// CHECK-NEXT:    [[CALL:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_Z3foov()
// CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[TERMINATE_LPAD:%.*]], !dbg [[DBG47:![0-9]+]]
// CHECK:       invoke.cont:
// CHECK-NEXT:    [[ATOMIC_LOAD:%.*]] = load atomic i32, i32* @a monotonic, align 4, !dbg [[DBG47]]
// CHECK-NEXT:    store i32 [[ATOMIC_LOAD]], i32* [[CALL]], align 4, !dbg [[DBG47]]
// CHECK-NEXT:    [[CALL2:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_Z3foov()
// CHECK-NEXT:    to label [[INVOKE_CONT1:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG48:![0-9]+]]
// CHECK:       invoke.cont1:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[CALL2]], align 4, !dbg [[DBG48]]
// CHECK-NEXT:    store atomic i32 [[TMP1]], i32* @a monotonic, align 4, !dbg [[DBG49:![0-9]+]]
// CHECK-NEXT:    [[CALL4:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_Z3foov()
// CHECK-NEXT:    to label [[INVOKE_CONT3:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG50:![0-9]+]]
// CHECK:       invoke.cont3:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* [[CALL4]], align 4, !dbg [[DBG50]]
// CHECK-NEXT:    [[TMP3:%.*]] = atomicrmw add i32* @a, i32 [[TMP2]] monotonic, align 4, !dbg [[DBG51:![0-9]+]]
// CHECK-NEXT:    [[CALL6:%.*]] = invoke noundef nonnull align 4 dereferenceable(4) i32* @_Z3foov()
// CHECK-NEXT:    to label [[INVOKE_CONT5:%.*]] unwind label [[TERMINATE_LPAD]], !dbg [[DBG52:![0-9]+]]
// CHECK:       invoke.cont5:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32* [[CALL6]], align 4, !dbg [[DBG52]]
// CHECK-NEXT:    [[TMP5:%.*]] = atomicrmw add i32* @a, i32 [[TMP4]] monotonic, align 4, !dbg [[DBG53:![0-9]+]]
// CHECK-NEXT:    store i32 [[TMP5]], i32* @b, align 4, !dbg [[DBG53]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]), !dbg [[DBG54:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG55:![0-9]+]]
// CHECK:       terminate.lpad:
// CHECK-NEXT:    [[TMP6:%.*]] = landingpad { i8*, i32 }
// CHECK-NEXT:    catch i8* null, !dbg [[DBG47]]
// CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { i8*, i32 } [[TMP6]], 0, !dbg [[DBG47]]
// CHECK-NEXT:    call void @__clang_call_terminate(i8* [[TMP7]]) #[[ATTR7]], !dbg [[DBG47]]
// CHECK-NEXT:    unreachable, !dbg [[DBG47]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2StC2Ev
// CHECK-SAME: (%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr #[[ATTR5]] comdat align 2 !dbg [[DBG56:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.St*, align 8
// CHECK-NEXT:    store %struct.St* [[THIS]], %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load %struct.St*, %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void, !dbg [[DBG57:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2StD2Ev
// CHECK-SAME: (%struct.St* noundef nonnull align 8 dereferenceable(8) [[THIS:%.*]]) unnamed_addr #[[ATTR5]] comdat align 2 !dbg [[DBG58:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca %struct.St*, align 8
// CHECK-NEXT:    store %struct.St* [[THIS]], %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load %struct.St*, %struct.St** [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void, !dbg [[DBG59:![0-9]+]]
//
